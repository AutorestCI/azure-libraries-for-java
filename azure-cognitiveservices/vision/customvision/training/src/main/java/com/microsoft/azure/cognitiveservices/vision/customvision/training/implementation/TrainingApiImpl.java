/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.cognitiveservices.vision.customvision.training.implementation;

import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureClient;
import com.microsoft.azure.AzureServiceClient;
import com.microsoft.azure.CloudException;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageFileCreateBatch;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageIdCreateBatch;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageRegionCreateBatch;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageRegionCreateEntry;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageTagCreateBatch;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageTagCreateEntry;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageUrl;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.ImageUrlCreateBatch;
import com.microsoft.azure.cognitiveservices.vision.customvision.training.PredictionQueryToken;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.credentials.ServiceClientCredentials;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.InputStream;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Multipart;
import retrofit2.http.Part;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the TrainingApiImpl class.
 */
public class TrainingApiImpl extends AzureServiceClient {
    /** The Retrofit service to perform REST calls. */
    private TrainingApiService service;
    /** the {@link AzureClient} used for long running operations. */
    private AzureClient azureClient;

    /**
     * Gets the {@link AzureClient} used for long running operations.
     * @return the azure client;
     */
    public AzureClient getAzureClient() {
        return this.azureClient;
    }

    /**  */
    private String apiKey;

    /**
     * Gets
     *
     * @return the apiKey value.
     */
    public String apiKey() {
        return this.apiKey;
    }

    /**
     * Sets
     *
     * @param apiKey the apiKey value.
     * @return the service client itself
     */
    public TrainingApiImpl withApiKey(String apiKey) {
        this.apiKey = apiKey;
        return this;
    }

    /** Gets or sets the preferred language for the response. */
    private String acceptLanguage;

    /**
     * Gets Gets or sets the preferred language for the response.
     *
     * @return the acceptLanguage value.
     */
    public String acceptLanguage() {
        return this.acceptLanguage;
    }

    /**
     * Sets Gets or sets the preferred language for the response.
     *
     * @param acceptLanguage the acceptLanguage value.
     * @return the service client itself
     */
    public TrainingApiImpl withAcceptLanguage(String acceptLanguage) {
        this.acceptLanguage = acceptLanguage;
        return this;
    }

    /** Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30. */
    private int longRunningOperationRetryTimeout;

    /**
     * Gets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @return the longRunningOperationRetryTimeout value.
     */
    public int longRunningOperationRetryTimeout() {
        return this.longRunningOperationRetryTimeout;
    }

    /**
     * Sets Gets or sets the retry timeout in seconds for Long Running Operations. Default value is 30.
     *
     * @param longRunningOperationRetryTimeout the longRunningOperationRetryTimeout value.
     * @return the service client itself
     */
    public TrainingApiImpl withLongRunningOperationRetryTimeout(int longRunningOperationRetryTimeout) {
        this.longRunningOperationRetryTimeout = longRunningOperationRetryTimeout;
        return this;
    }

    /** When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true. */
    private boolean generateClientRequestId;

    /**
     * Gets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @return the generateClientRequestId value.
     */
    public boolean generateClientRequestId() {
        return this.generateClientRequestId;
    }

    /**
     * Sets When set to true a unique x-ms-client-request-id value is generated and included in each request. Default is true.
     *
     * @param generateClientRequestId the generateClientRequestId value.
     * @return the service client itself
     */
    public TrainingApiImpl withGenerateClientRequestId(boolean generateClientRequestId) {
        this.generateClientRequestId = generateClientRequestId;
        return this;
    }

    /**
     * Initializes an instance of TrainingApi client.
     *
     * @param credentials the management credentials for Azure
     */
    public TrainingApiImpl(ServiceClientCredentials credentials) {
        this("https://southcentralus.api.cognitive.microsoft.com/customvision/v2.0/Training", credentials);
    }

    /**
     * Initializes an instance of TrainingApi client.
     *
     * @param baseUrl the base URL of the host
     * @param credentials the management credentials for Azure
     */
    public TrainingApiImpl(String baseUrl, ServiceClientCredentials credentials) {
        super(baseUrl, credentials);
        initialize();
    }

    /**
     * Initializes an instance of TrainingApi client.
     *
     * @param restClient the REST client to connect to Azure.
     */
    public TrainingApiImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    protected void initialize() {
        this.acceptLanguage = "en-US";
        this.longRunningOperationRetryTimeout = 30;
        this.generateClientRequestId = true;
        this.azureClient = new AzureClient(this);
        initializeService();
    }

    /**
     * Gets the User-Agent header for the client.
     *
     * @return the user agent string.
     */
    @Override
    public String userAgent() {
        return String.format("%s (%s, %s)", super.userAgent(), "TrainingApi", "2.0");
    }

    private void initializeService() {
        service = restClient().retrofit().create(TrainingApiService.class);
    }

    /**
     * The interface defining all the services for TrainingApi to be
     * used by Retrofit to perform actually REST calls.
     */
    interface TrainingApiService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getDomains" })
        @GET("domains")
        Observable<Response<ResponseBody>> getDomains(@Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getDomain" })
        @GET("domains/{domainId}")
        Observable<Response<ResponseBody>> getDomain(@Path("domainId") UUID domainId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getTaggedImages" })
        @GET("projects/{projectId}/images/tagged")
        Observable<Response<ResponseBody>> getTaggedImages(@Path("projectId") UUID projectId, @Query("iterationId") UUID iterationId, @Query("tagIds") String tagIds, @Query("orderBy") String orderBy, @Query("take") Integer take, @Query("skip") Integer skip, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getUntaggedImages" })
        @GET("projects/{projectId}/images/untagged")
        Observable<Response<ResponseBody>> getUntaggedImages(@Path("projectId") UUID projectId, @Query("iterationId") UUID iterationId, @Query("orderBy") String orderBy, @Query("take") Integer take, @Query("skip") Integer skip, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getTaggedImageCount" })
        @GET("projects/{projectId}/images/tagged/count")
        Observable<Response<ResponseBody>> getTaggedImageCount(@Path("projectId") UUID projectId, @Query("iterationId") UUID iterationId, @Query("tagIds") String tagIds, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getUntaggedImageCount" })
        @GET("projects/{projectId}/images/untagged/count")
        Observable<Response<ResponseBody>> getUntaggedImageCount(@Path("projectId") UUID projectId, @Query("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getImagesByIds" })
        @GET("projects/{projectId}/images/id")
        Observable<Response<ResponseBody>> getImagesByIds(@Path("projectId") UUID projectId, @Query("imageIds") String imageIds, @Query("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Multipart
        @POST("projects/{projectId}/images")
        Observable<Response<ResponseBody>> createImagesFromData(@Path("projectId") UUID projectId, @Query("tagIds") String tagIds, @Part("imageData") RequestBody imageData, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi deleteImages" })
        @HTTP(path = "projects/{projectId}/images", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteImages(@Path("projectId") UUID projectId, @Query("imageIds") String imageIds, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi createImagesFromFiles" })
        @POST("projects/{projectId}/images/files")
        Observable<Response<ResponseBody>> createImagesFromFiles(@Path("projectId") UUID projectId, @Body ImageFileCreateBatch batch, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi createImagesFromUrls" })
        @POST("projects/{projectId}/images/urls")
        Observable<Response<ResponseBody>> createImagesFromUrls(@Path("projectId") UUID projectId, @Body ImageUrlCreateBatch batch, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi createImagesFromPredictions" })
        @POST("projects/{projectId}/images/predictions")
        Observable<Response<ResponseBody>> createImagesFromPredictions(@Path("projectId") UUID projectId, @Body ImageIdCreateBatch batch, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi createImageTags" })
        @POST("projects/{projectId}/images/tags")
        Observable<Response<ResponseBody>> createImageTags(@Path("projectId") UUID projectId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Body ImageTagCreateBatch batch, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi deleteImageTags" })
        @HTTP(path = "projects/{projectId}/images/tags", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteImageTags(@Path("projectId") UUID projectId, @Query("imageIds") String imageIds, @Query("tagIds") String tagIds, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi createImageRegions" })
        @POST("projects/{projectId}/images/regions")
        Observable<Response<ResponseBody>> createImageRegions(@Path("projectId") UUID projectId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Body ImageRegionCreateBatch batch, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi deleteImageRegions" })
        @HTTP(path = "projects/{projectId}/images/regions", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteImageRegions(@Path("projectId") UUID projectId, @Query("regionIds") String regionIds, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getImageRegionProposals" })
        @POST("{projectId}/images/{imageId}/regionproposals")
        Observable<Response<ResponseBody>> getImageRegionProposals(@Path("projectId") UUID projectId, @Path("imageId") UUID imageId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi deletePrediction" })
        @HTTP(path = "projects/{projectId}/predictions", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletePrediction(@Path("projectId") UUID projectId, @Query("ids") String ids, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi queryPredictions" })
        @POST("projects/{projectId}/predictions/query")
        Observable<Response<ResponseBody>> queryPredictions(@Path("projectId") UUID projectId, @Body PredictionQueryToken query, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi quickTestImageUrl" })
        @POST("projects/{projectId}/quicktest/url")
        Observable<Response<ResponseBody>> quickTestImageUrl(@Path("projectId") UUID projectId, @Query("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Body ImageUrl imageUrl, @Header("User-Agent") String userAgent);

        @Multipart
        @POST("projects/{projectId}/quicktest/image")
        Observable<Response<ResponseBody>> quickTestImage(@Path("projectId") UUID projectId, @Query("iterationId") UUID iterationId, @Part("imageData") RequestBody imageData, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi trainProject" })
        @POST("projects/{projectId}/train")
        Observable<Response<ResponseBody>> trainProject(@Path("projectId") UUID projectId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getProjects" })
        @GET("projects")
        Observable<Response<ResponseBody>> getProjects(@Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi createProject" })
        @POST("projects")
        Observable<Response<ResponseBody>> createProject(@Query("name") String name, @Query("description") String description, @Query("domainId") UUID domainId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getProject" })
        @GET("projects/{projectId}")
        Observable<Response<ResponseBody>> getProject(@Path("projectId") UUID projectId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi deleteProject" })
        @HTTP(path = "projects/{projectId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteProject(@Path("projectId") UUID projectId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi updateProject" })
        @PATCH("projects/{projectId}")
        Observable<Response<ResponseBody>> updateProject(@Path("projectId") UUID projectId, @Body ProjectInner updatedProject, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getIterations" })
        @GET("projects/{projectId}/iterations")
        Observable<Response<ResponseBody>> getIterations(@Path("projectId") UUID projectId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getIteration" })
        @GET("projects/{projectId}/iterations/{iterationId}")
        Observable<Response<ResponseBody>> getIteration(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi deleteIteration" })
        @HTTP(path = "projects/{projectId}/iterations/{iterationId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteIteration(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi updateIteration" })
        @PATCH("projects/{projectId}/iterations/{iterationId}")
        Observable<Response<ResponseBody>> updateIteration(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Body IterationInner updatedIteration, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getIterationPerformance" })
        @GET("projects/{projectId}/iterations/{iterationId}/performance")
        Observable<Response<ResponseBody>> getIterationPerformance(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Query("threshold") Double threshold, @Query("overlapThreshold") Double overlapThreshold, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getImagePerformances" })
        @GET("projects/{projectId}/iterations/{iterationId}/performance/images")
        Observable<Response<ResponseBody>> getImagePerformances(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Query("tagIds") String tagIds, @Query("orderBy") String orderBy, @Query("take") Integer take, @Query("skip") Integer skip, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getImagePerformanceCount" })
        @GET("projects/{projectId}/iterations/{iterationId}/performance/images/count")
        Observable<Response<ResponseBody>> getImagePerformanceCount(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Query("tagIds") String tagIds, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getExports" })
        @GET("projects/{projectId}/iterations/{iterationId}/export")
        Observable<Response<ResponseBody>> getExports(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi exportIteration" })
        @POST("projects/{projectId}/iterations/{iterationId}/export")
        Observable<Response<ResponseBody>> exportIteration(@Path("projectId") UUID projectId, @Path("iterationId") UUID iterationId, @Query("platform") String platform, @Query("flavor") String flavor, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getTag" })
        @GET("projects/{projectId}/tags/{tagId}")
        Observable<Response<ResponseBody>> getTag(@Path("projectId") UUID projectId, @Path("tagId") UUID tagId, @Query("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi deleteTag" })
        @HTTP(path = "projects/{projectId}/tags/{tagId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteTag(@Path("projectId") UUID projectId, @Path("tagId") UUID tagId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi updateTag" })
        @PATCH("projects/{projectId}/tags/{tagId}")
        Observable<Response<ResponseBody>> updateTag(@Path("projectId") UUID projectId, @Path("tagId") UUID tagId, @Body TagInner updatedTag, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi getTags" })
        @GET("projects/{projectId}/tags")
        Observable<Response<ResponseBody>> getTags(@Path("projectId") UUID projectId, @Query("iterationId") UUID iterationId, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.cognitiveservices.vision.customvision.training.TrainingApi createTag" })
        @POST("projects/{projectId}/tags")
        Observable<Response<ResponseBody>> createTag(@Path("projectId") UUID projectId, @Query("name") String name, @Query("description") String description, @Header("Training-Key") String apiKey, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Get a list of the available domains.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DomainInner&gt; object if successful.
     */
    public List<DomainInner> getDomains() {
        return getDomainsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get a list of the available domains.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DomainInner>> getDomainsAsync(final ServiceCallback<List<DomainInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getDomainsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get a list of the available domains.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DomainInner&gt; object
     */
    public Observable<List<DomainInner>> getDomainsAsync() {
        return getDomainsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DomainInner>>, List<DomainInner>>() {
            @Override
            public List<DomainInner> call(ServiceResponse<List<DomainInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a list of the available domains.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DomainInner&gt; object
     */
    public Observable<ServiceResponse<List<DomainInner>>> getDomainsWithServiceResponseAsync() {
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getDomains(this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DomainInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<DomainInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DomainInner>> clientResponse = getDomainsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DomainInner>> getDomainsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<DomainInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DomainInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get information about a specific domain.
     *
     * @param domainId The id of the domain to get information about
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DomainInner object if successful.
     */
    public DomainInner getDomain(UUID domainId) {
        return getDomainWithServiceResponseAsync(domainId).toBlocking().single().body();
    }

    /**
     * Get information about a specific domain.
     *
     * @param domainId The id of the domain to get information about
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DomainInner> getDomainAsync(UUID domainId, final ServiceCallback<DomainInner> serviceCallback) {
        return ServiceFuture.fromResponse(getDomainWithServiceResponseAsync(domainId), serviceCallback);
    }

    /**
     * Get information about a specific domain.
     *
     * @param domainId The id of the domain to get information about
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DomainInner object
     */
    public Observable<DomainInner> getDomainAsync(UUID domainId) {
        return getDomainWithServiceResponseAsync(domainId).map(new Func1<ServiceResponse<DomainInner>, DomainInner>() {
            @Override
            public DomainInner call(ServiceResponse<DomainInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get information about a specific domain.
     *
     * @param domainId The id of the domain to get information about
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DomainInner object
     */
    public Observable<ServiceResponse<DomainInner>> getDomainWithServiceResponseAsync(UUID domainId) {
        if (domainId == null) {
            throw new IllegalArgumentException("Parameter domainId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getDomain(domainId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DomainInner>>>() {
                @Override
                public Observable<ServiceResponse<DomainInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DomainInner> clientResponse = getDomainDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DomainInner> getDomainDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DomainInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DomainInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImageInner&gt; object if successful.
     */
    public List<ImageInner> getTaggedImages(UUID projectId) {
        return getTaggedImagesWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImageInner>> getTaggedImagesAsync(UUID projectId, final ServiceCallback<List<ImageInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getTaggedImagesWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<List<ImageInner>> getTaggedImagesAsync(UUID projectId) {
        return getTaggedImagesWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<List<ImageInner>>, List<ImageInner>>() {
            @Override
            public List<ImageInner> call(ServiceResponse<List<ImageInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<ServiceResponse<List<ImageInner>>> getTaggedImagesWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        final List<String> tagIds = null;
        final String orderBy = null;
        final Integer take = null;
        final Integer skip = null;
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getTaggedImages(projectId, iterationId, tagIdsConverted, orderBy, take, skip, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImageInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImageInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImageInner>> clientResponse = getTaggedImagesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImageInner&gt; object if successful.
     */
    public List<ImageInner> getTaggedImages(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip) {
        return getTaggedImagesWithServiceResponseAsync(projectId, iterationId, tagIds, orderBy, take, skip).toBlocking().single().body();
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImageInner>> getTaggedImagesAsync(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip, final ServiceCallback<List<ImageInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getTaggedImagesWithServiceResponseAsync(projectId, iterationId, tagIds, orderBy, take, skip), serviceCallback);
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<List<ImageInner>> getTaggedImagesAsync(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip) {
        return getTaggedImagesWithServiceResponseAsync(projectId, iterationId, tagIds, orderBy, take, skip).map(new Func1<ServiceResponse<List<ImageInner>>, List<ImageInner>>() {
            @Override
            public List<ImageInner> call(ServiceResponse<List<ImageInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get tagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<ServiceResponse<List<ImageInner>>> getTaggedImagesWithServiceResponseAsync(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(tagIds);
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getTaggedImages(projectId, iterationId, tagIdsConverted, orderBy, take, skip, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImageInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImageInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImageInner>> clientResponse = getTaggedImagesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ImageInner>> getTaggedImagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ImageInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ImageInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImageInner&gt; object if successful.
     */
    public List<ImageInner> getUntaggedImages(UUID projectId) {
        return getUntaggedImagesWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImageInner>> getUntaggedImagesAsync(UUID projectId, final ServiceCallback<List<ImageInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getUntaggedImagesWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<List<ImageInner>> getUntaggedImagesAsync(UUID projectId) {
        return getUntaggedImagesWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<List<ImageInner>>, List<ImageInner>>() {
            @Override
            public List<ImageInner> call(ServiceResponse<List<ImageInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<ServiceResponse<List<ImageInner>>> getUntaggedImagesWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        final String orderBy = null;
        final Integer take = null;
        final Integer skip = null;
        return service.getUntaggedImages(projectId, iterationId, orderBy, take, skip, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImageInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImageInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImageInner>> clientResponse = getUntaggedImagesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImageInner&gt; object if successful.
     */
    public List<ImageInner> getUntaggedImages(UUID projectId, UUID iterationId, String orderBy, Integer take, Integer skip) {
        return getUntaggedImagesWithServiceResponseAsync(projectId, iterationId, orderBy, take, skip).toBlocking().single().body();
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImageInner>> getUntaggedImagesAsync(UUID projectId, UUID iterationId, String orderBy, Integer take, Integer skip, final ServiceCallback<List<ImageInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getUntaggedImagesWithServiceResponseAsync(projectId, iterationId, orderBy, take, skip), serviceCallback);
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<List<ImageInner>> getUntaggedImagesAsync(UUID projectId, UUID iterationId, String orderBy, Integer take, Integer skip) {
        return getUntaggedImagesWithServiceResponseAsync(projectId, iterationId, orderBy, take, skip).map(new Func1<ServiceResponse<List<ImageInner>>, List<ImageInner>>() {
            @Override
            public List<ImageInner> call(ServiceResponse<List<ImageInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get untagged images for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<ServiceResponse<List<ImageInner>>> getUntaggedImagesWithServiceResponseAsync(UUID projectId, UUID iterationId, String orderBy, Integer take, Integer skip) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getUntaggedImages(projectId, iterationId, orderBy, take, skip, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImageInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImageInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImageInner>> clientResponse = getUntaggedImagesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ImageInner>> getUntaggedImagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ImageInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ImageInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int getTaggedImageCount(UUID projectId) {
        return getTaggedImageCountWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> getTaggedImageCountAsync(UUID projectId, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(getTaggedImageCountWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> getTaggedImageCountAsync(UUID projectId) {
        return getTaggedImageCountWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> getTaggedImageCountWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        final List<String> tagIds = null;
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getTaggedImageCount(projectId, iterationId, tagIdsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = getTaggedImageCountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int getTaggedImageCount(UUID projectId, UUID iterationId, List<String> tagIds) {
        return getTaggedImageCountWithServiceResponseAsync(projectId, iterationId, tagIds).toBlocking().single().body();
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> getTaggedImageCountAsync(UUID projectId, UUID iterationId, List<String> tagIds, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(getTaggedImageCountWithServiceResponseAsync(projectId, iterationId, tagIds), serviceCallback);
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> getTaggedImageCountAsync(UUID projectId, UUID iterationId, List<String> tagIds) {
        return getTaggedImageCountWithServiceResponseAsync(projectId, iterationId, tagIds).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the number of images tagged with the provided {tagIds}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> getTaggedImageCountWithServiceResponseAsync(UUID projectId, UUID iterationId, List<String> tagIds) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(tagIds);
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getTaggedImageCount(projectId, iterationId, tagIdsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = getTaggedImageCountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Integer> getTaggedImageCountDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Integer, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Integer>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int getUntaggedImageCount(UUID projectId) {
        return getUntaggedImageCountWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> getUntaggedImageCountAsync(UUID projectId, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(getUntaggedImageCountWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> getUntaggedImageCountAsync(UUID projectId) {
        return getUntaggedImageCountWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> getUntaggedImageCountWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        return service.getUntaggedImageCount(projectId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = getUntaggedImageCountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int getUntaggedImageCount(UUID projectId, UUID iterationId) {
        return getUntaggedImageCountWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> getUntaggedImageCountAsync(UUID projectId, UUID iterationId, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(getUntaggedImageCountWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> getUntaggedImageCountAsync(UUID projectId, UUID iterationId) {
        return getUntaggedImageCountWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the number of untagged images.
     * This API returns the images which have no tags for a given project and optionally an iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> getUntaggedImageCountWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getUntaggedImageCount(projectId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = getUntaggedImageCountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Integer> getUntaggedImageCountDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Integer, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Integer>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImageInner&gt; object if successful.
     */
    public List<ImageInner> getImagesByIds(UUID projectId) {
        return getImagesByIdsWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImageInner>> getImagesByIdsAsync(UUID projectId, final ServiceCallback<List<ImageInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getImagesByIdsWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<List<ImageInner>> getImagesByIdsAsync(UUID projectId) {
        return getImagesByIdsWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<List<ImageInner>>, List<ImageInner>>() {
            @Override
            public List<ImageInner> call(ServiceResponse<List<ImageInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<ServiceResponse<List<ImageInner>>> getImagesByIdsWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final List<String> imageIds = null;
        final UUID iterationId = null;
        String imageIdsConverted = this.serializerAdapter().serializeList(imageIds, CollectionFormat.CSV);
        return service.getImagesByIds(projectId, imageIdsConverted, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImageInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImageInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImageInner>> clientResponse = getImagesByIdsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param imageIds The list of image ids to retrieve. Limited to 256
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImageInner&gt; object if successful.
     */
    public List<ImageInner> getImagesByIds(UUID projectId, List<String> imageIds, UUID iterationId) {
        return getImagesByIdsWithServiceResponseAsync(projectId, imageIds, iterationId).toBlocking().single().body();
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param imageIds The list of image ids to retrieve. Limited to 256
     * @param iterationId The iteration id. Defaults to workspace
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImageInner>> getImagesByIdsAsync(UUID projectId, List<String> imageIds, UUID iterationId, final ServiceCallback<List<ImageInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getImagesByIdsWithServiceResponseAsync(projectId, imageIds, iterationId), serviceCallback);
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param imageIds The list of image ids to retrieve. Limited to 256
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<List<ImageInner>> getImagesByIdsAsync(UUID projectId, List<String> imageIds, UUID iterationId) {
        return getImagesByIdsWithServiceResponseAsync(projectId, imageIds, iterationId).map(new Func1<ServiceResponse<List<ImageInner>>, List<ImageInner>>() {
            @Override
            public List<ImageInner> call(ServiceResponse<List<ImageInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get images by id for a given project iteration.
     * This API will return a set of Images for the specified tags and optionally iteration. If no iteration is specified the
     current workspace is used.
     *
     * @param projectId The project id
     * @param imageIds The list of image ids to retrieve. Limited to 256
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImageInner&gt; object
     */
    public Observable<ServiceResponse<List<ImageInner>>> getImagesByIdsWithServiceResponseAsync(UUID projectId, List<String> imageIds, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(imageIds);
        String imageIdsConverted = this.serializerAdapter().serializeList(imageIds, CollectionFormat.CSV);
        return service.getImagesByIds(projectId, imageIdsConverted, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImageInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImageInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImageInner>> clientResponse = getImagesByIdsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ImageInner>> getImagesByIdsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ImageInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ImageInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageCreateSummaryInner object if successful.
     */
    public ImageCreateSummaryInner createImagesFromData(UUID projectId, byte[] imageData) {
        return createImagesFromDataWithServiceResponseAsync(projectId, imageData).toBlocking().single().body();
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageCreateSummaryInner> createImagesFromDataAsync(UUID projectId, byte[] imageData, final ServiceCallback<ImageCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImagesFromDataWithServiceResponseAsync(projectId, imageData), serviceCallback);
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ImageCreateSummaryInner> createImagesFromDataAsync(UUID projectId, byte[] imageData) {
        return createImagesFromDataWithServiceResponseAsync(projectId, imageData).map(new Func1<ServiceResponse<ImageCreateSummaryInner>, ImageCreateSummaryInner>() {
            @Override
            public ImageCreateSummaryInner call(ServiceResponse<ImageCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageCreateSummaryInner>> createImagesFromDataWithServiceResponseAsync(UUID projectId, byte[] imageData) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (imageData == null) {
            throw new IllegalArgumentException("Parameter imageData is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final List<String> tagIds = null;
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);RequestBody imageDataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), imageData);
        return service.createImagesFromData(projectId, tagIdsConverted, imageDataConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageCreateSummaryInner> clientResponse = createImagesFromDataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param tagIds The tags ids with which to tag each image. Limited to 20
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageCreateSummaryInner object if successful.
     */
    public ImageCreateSummaryInner createImagesFromData(UUID projectId, byte[] imageData, List<String> tagIds) {
        return createImagesFromDataWithServiceResponseAsync(projectId, imageData, tagIds).toBlocking().single().body();
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param tagIds The tags ids with which to tag each image. Limited to 20
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageCreateSummaryInner> createImagesFromDataAsync(UUID projectId, byte[] imageData, List<String> tagIds, final ServiceCallback<ImageCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImagesFromDataWithServiceResponseAsync(projectId, imageData, tagIds), serviceCallback);
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param tagIds The tags ids with which to tag each image. Limited to 20
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ImageCreateSummaryInner> createImagesFromDataAsync(UUID projectId, byte[] imageData, List<String> tagIds) {
        return createImagesFromDataWithServiceResponseAsync(projectId, imageData, tagIds).map(new Func1<ServiceResponse<ImageCreateSummaryInner>, ImageCreateSummaryInner>() {
            @Override
            public ImageCreateSummaryInner call(ServiceResponse<ImageCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Add the provided images to the set of training images.
     * This API accepts body content as multipart/form-data and application/octet-stream. When using multipart
     multiple image files can be sent at once, with a maximum of 64 files.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param tagIds The tags ids with which to tag each image. Limited to 20
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageCreateSummaryInner>> createImagesFromDataWithServiceResponseAsync(UUID projectId, byte[] imageData, List<String> tagIds) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (imageData == null) {
            throw new IllegalArgumentException("Parameter imageData is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(tagIds);
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);RequestBody imageDataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), imageData);
        return service.createImagesFromData(projectId, tagIdsConverted, imageDataConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageCreateSummaryInner> clientResponse = createImagesFromDataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageCreateSummaryInner> createImagesFromDataDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageCreateSummaryInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageCreateSummaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete images from the set of training images.
     *
     * @param projectId The project id
     * @param imageIds Ids of the images to be deleted. Limted to 256 images per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteImages(UUID projectId, List<String> imageIds) {
        deleteImagesWithServiceResponseAsync(projectId, imageIds).toBlocking().single().body();
    }

    /**
     * Delete images from the set of training images.
     *
     * @param projectId The project id
     * @param imageIds Ids of the images to be deleted. Limted to 256 images per batch
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteImagesAsync(UUID projectId, List<String> imageIds, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteImagesWithServiceResponseAsync(projectId, imageIds), serviceCallback);
    }

    /**
     * Delete images from the set of training images.
     *
     * @param projectId The project id
     * @param imageIds Ids of the images to be deleted. Limted to 256 images per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteImagesAsync(UUID projectId, List<String> imageIds) {
        return deleteImagesWithServiceResponseAsync(projectId, imageIds).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete images from the set of training images.
     *
     * @param projectId The project id
     * @param imageIds Ids of the images to be deleted. Limted to 256 images per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteImagesWithServiceResponseAsync(UUID projectId, List<String> imageIds) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (imageIds == null) {
            throw new IllegalArgumentException("Parameter imageIds is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(imageIds);
        String imageIdsConverted = this.serializerAdapter().serializeList(imageIds, CollectionFormat.CSV);
        return service.deleteImages(projectId, imageIdsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteImagesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteImagesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Add the provided batch of images to the set of training images.
     * This API accepts a batch of files, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch The batch of image files to add. Limited to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageCreateSummaryInner object if successful.
     */
    public ImageCreateSummaryInner createImagesFromFiles(UUID projectId, ImageFileCreateBatch batch) {
        return createImagesFromFilesWithServiceResponseAsync(projectId, batch).toBlocking().single().body();
    }

    /**
     * Add the provided batch of images to the set of training images.
     * This API accepts a batch of files, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch The batch of image files to add. Limited to 64 images and 20 tags per batch
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageCreateSummaryInner> createImagesFromFilesAsync(UUID projectId, ImageFileCreateBatch batch, final ServiceCallback<ImageCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImagesFromFilesWithServiceResponseAsync(projectId, batch), serviceCallback);
    }

    /**
     * Add the provided batch of images to the set of training images.
     * This API accepts a batch of files, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch The batch of image files to add. Limited to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ImageCreateSummaryInner> createImagesFromFilesAsync(UUID projectId, ImageFileCreateBatch batch) {
        return createImagesFromFilesWithServiceResponseAsync(projectId, batch).map(new Func1<ServiceResponse<ImageCreateSummaryInner>, ImageCreateSummaryInner>() {
            @Override
            public ImageCreateSummaryInner call(ServiceResponse<ImageCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Add the provided batch of images to the set of training images.
     * This API accepts a batch of files, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch The batch of image files to add. Limited to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageCreateSummaryInner>> createImagesFromFilesWithServiceResponseAsync(UUID projectId, ImageFileCreateBatch batch) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (batch == null) {
            throw new IllegalArgumentException("Parameter batch is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(batch);
        return service.createImagesFromFiles(projectId, batch, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageCreateSummaryInner> clientResponse = createImagesFromFilesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageCreateSummaryInner> createImagesFromFilesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageCreateSummaryInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageCreateSummaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Add the provided images urls to the set of training images.
     * This API accepts a batch of urls, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image urls and tag ids. Limited to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageCreateSummaryInner object if successful.
     */
    public ImageCreateSummaryInner createImagesFromUrls(UUID projectId, ImageUrlCreateBatch batch) {
        return createImagesFromUrlsWithServiceResponseAsync(projectId, batch).toBlocking().single().body();
    }

    /**
     * Add the provided images urls to the set of training images.
     * This API accepts a batch of urls, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image urls and tag ids. Limited to 64 images and 20 tags per batch
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageCreateSummaryInner> createImagesFromUrlsAsync(UUID projectId, ImageUrlCreateBatch batch, final ServiceCallback<ImageCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImagesFromUrlsWithServiceResponseAsync(projectId, batch), serviceCallback);
    }

    /**
     * Add the provided images urls to the set of training images.
     * This API accepts a batch of urls, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image urls and tag ids. Limited to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ImageCreateSummaryInner> createImagesFromUrlsAsync(UUID projectId, ImageUrlCreateBatch batch) {
        return createImagesFromUrlsWithServiceResponseAsync(projectId, batch).map(new Func1<ServiceResponse<ImageCreateSummaryInner>, ImageCreateSummaryInner>() {
            @Override
            public ImageCreateSummaryInner call(ServiceResponse<ImageCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Add the provided images urls to the set of training images.
     * This API accepts a batch of urls, and optionally tags, to create images. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image urls and tag ids. Limited to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageCreateSummaryInner>> createImagesFromUrlsWithServiceResponseAsync(UUID projectId, ImageUrlCreateBatch batch) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (batch == null) {
            throw new IllegalArgumentException("Parameter batch is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(batch);
        return service.createImagesFromUrls(projectId, batch, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageCreateSummaryInner> clientResponse = createImagesFromUrlsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageCreateSummaryInner> createImagesFromUrlsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageCreateSummaryInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageCreateSummaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Add the specified predicted images to the set of training images.
     * This API creates a batch of images from predicted images specified. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image and tag ids. Limted to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageCreateSummaryInner object if successful.
     */
    public ImageCreateSummaryInner createImagesFromPredictions(UUID projectId, ImageIdCreateBatch batch) {
        return createImagesFromPredictionsWithServiceResponseAsync(projectId, batch).toBlocking().single().body();
    }

    /**
     * Add the specified predicted images to the set of training images.
     * This API creates a batch of images from predicted images specified. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image and tag ids. Limted to 64 images and 20 tags per batch
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageCreateSummaryInner> createImagesFromPredictionsAsync(UUID projectId, ImageIdCreateBatch batch, final ServiceCallback<ImageCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImagesFromPredictionsWithServiceResponseAsync(projectId, batch), serviceCallback);
    }

    /**
     * Add the specified predicted images to the set of training images.
     * This API creates a batch of images from predicted images specified. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image and tag ids. Limted to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ImageCreateSummaryInner> createImagesFromPredictionsAsync(UUID projectId, ImageIdCreateBatch batch) {
        return createImagesFromPredictionsWithServiceResponseAsync(projectId, batch).map(new Func1<ServiceResponse<ImageCreateSummaryInner>, ImageCreateSummaryInner>() {
            @Override
            public ImageCreateSummaryInner call(ServiceResponse<ImageCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Add the specified predicted images to the set of training images.
     * This API creates a batch of images from predicted images specified. There is a limit of 64 images and 20 tags.
     *
     * @param projectId The project id
     * @param batch Image and tag ids. Limted to 64 images and 20 tags per batch
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageCreateSummaryInner>> createImagesFromPredictionsWithServiceResponseAsync(UUID projectId, ImageIdCreateBatch batch) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (batch == null) {
            throw new IllegalArgumentException("Parameter batch is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(batch);
        return service.createImagesFromPredictions(projectId, batch, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageCreateSummaryInner> clientResponse = createImagesFromPredictionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageCreateSummaryInner> createImagesFromPredictionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageCreateSummaryInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageCreateSummaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageTagCreateSummaryInner object if successful.
     */
    public ImageTagCreateSummaryInner createImageTags(UUID projectId) {
        return createImageTagsWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageTagCreateSummaryInner> createImageTagsAsync(UUID projectId, final ServiceCallback<ImageTagCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImageTagsWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageTagCreateSummaryInner object
     */
    public Observable<ImageTagCreateSummaryInner> createImageTagsAsync(UUID projectId) {
        return createImageTagsWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<ImageTagCreateSummaryInner>, ImageTagCreateSummaryInner>() {
            @Override
            public ImageTagCreateSummaryInner call(ServiceResponse<ImageTagCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageTagCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageTagCreateSummaryInner>> createImageTagsWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final List<ImageTagCreateEntry> tags = null;
        ImageTagCreateBatch batch = new ImageTagCreateBatch();
        batch.withTags(null);
        return service.createImageTags(projectId, this.apiKey(), this.acceptLanguage(), batch, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageTagCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageTagCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageTagCreateSummaryInner> clientResponse = createImageTagsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @param tags the List&lt;ImageTagCreateEntry&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageTagCreateSummaryInner object if successful.
     */
    public ImageTagCreateSummaryInner createImageTags(UUID projectId, List<ImageTagCreateEntry> tags) {
        return createImageTagsWithServiceResponseAsync(projectId, tags).toBlocking().single().body();
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @param tags the List&lt;ImageTagCreateEntry&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageTagCreateSummaryInner> createImageTagsAsync(UUID projectId, List<ImageTagCreateEntry> tags, final ServiceCallback<ImageTagCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImageTagsWithServiceResponseAsync(projectId, tags), serviceCallback);
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @param tags the List&lt;ImageTagCreateEntry&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageTagCreateSummaryInner object
     */
    public Observable<ImageTagCreateSummaryInner> createImageTagsAsync(UUID projectId, List<ImageTagCreateEntry> tags) {
        return createImageTagsWithServiceResponseAsync(projectId, tags).map(new Func1<ServiceResponse<ImageTagCreateSummaryInner>, ImageTagCreateSummaryInner>() {
            @Override
            public ImageTagCreateSummaryInner call(ServiceResponse<ImageTagCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Associate a set of images with a set of tags.
     *
     * @param projectId The project id
     * @param tags the List&lt;ImageTagCreateEntry&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageTagCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageTagCreateSummaryInner>> createImageTagsWithServiceResponseAsync(UUID projectId, List<ImageTagCreateEntry> tags) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(tags);
        ImageTagCreateBatch batch = new ImageTagCreateBatch();
        batch.withTags(tags);
        return service.createImageTags(projectId, this.apiKey(), this.acceptLanguage(), batch, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageTagCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageTagCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageTagCreateSummaryInner> clientResponse = createImageTagsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageTagCreateSummaryInner> createImageTagsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageTagCreateSummaryInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageTagCreateSummaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Remove a set of tags from a set of images.
     *
     * @param projectId The project id
     * @param imageIds Image ids. Limited to 64 images
     * @param tagIds Tags to be deleted from the specified images. Limted to 20 tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteImageTags(UUID projectId, List<String> imageIds, List<String> tagIds) {
        deleteImageTagsWithServiceResponseAsync(projectId, imageIds, tagIds).toBlocking().single().body();
    }

    /**
     * Remove a set of tags from a set of images.
     *
     * @param projectId The project id
     * @param imageIds Image ids. Limited to 64 images
     * @param tagIds Tags to be deleted from the specified images. Limted to 20 tags
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteImageTagsAsync(UUID projectId, List<String> imageIds, List<String> tagIds, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteImageTagsWithServiceResponseAsync(projectId, imageIds, tagIds), serviceCallback);
    }

    /**
     * Remove a set of tags from a set of images.
     *
     * @param projectId The project id
     * @param imageIds Image ids. Limited to 64 images
     * @param tagIds Tags to be deleted from the specified images. Limted to 20 tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteImageTagsAsync(UUID projectId, List<String> imageIds, List<String> tagIds) {
        return deleteImageTagsWithServiceResponseAsync(projectId, imageIds, tagIds).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Remove a set of tags from a set of images.
     *
     * @param projectId The project id
     * @param imageIds Image ids. Limited to 64 images
     * @param tagIds Tags to be deleted from the specified images. Limted to 20 tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteImageTagsWithServiceResponseAsync(UUID projectId, List<String> imageIds, List<String> tagIds) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (imageIds == null) {
            throw new IllegalArgumentException("Parameter imageIds is required and cannot be null.");
        }
        if (tagIds == null) {
            throw new IllegalArgumentException("Parameter tagIds is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(imageIds);
        Validator.validate(tagIds);
        String imageIdsConverted = this.serializerAdapter().serializeList(imageIds, CollectionFormat.CSV);String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.deleteImageTags(projectId, imageIdsConverted, tagIdsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteImageTagsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteImageTagsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageRegionCreateSummaryInner object if successful.
     */
    public ImageRegionCreateSummaryInner createImageRegions(UUID projectId) {
        return createImageRegionsWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageRegionCreateSummaryInner> createImageRegionsAsync(UUID projectId, final ServiceCallback<ImageRegionCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImageRegionsWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageRegionCreateSummaryInner object
     */
    public Observable<ImageRegionCreateSummaryInner> createImageRegionsAsync(UUID projectId) {
        return createImageRegionsWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<ImageRegionCreateSummaryInner>, ImageRegionCreateSummaryInner>() {
            @Override
            public ImageRegionCreateSummaryInner call(ServiceResponse<ImageRegionCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageRegionCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageRegionCreateSummaryInner>> createImageRegionsWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final List<ImageRegionCreateEntry> regions = null;
        ImageRegionCreateBatch batch = new ImageRegionCreateBatch();
        batch.withRegions(null);
        return service.createImageRegions(projectId, this.apiKey(), this.acceptLanguage(), batch, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageRegionCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageRegionCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageRegionCreateSummaryInner> clientResponse = createImageRegionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @param regions the List&lt;ImageRegionCreateEntry&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageRegionCreateSummaryInner object if successful.
     */
    public ImageRegionCreateSummaryInner createImageRegions(UUID projectId, List<ImageRegionCreateEntry> regions) {
        return createImageRegionsWithServiceResponseAsync(projectId, regions).toBlocking().single().body();
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @param regions the List&lt;ImageRegionCreateEntry&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageRegionCreateSummaryInner> createImageRegionsAsync(UUID projectId, List<ImageRegionCreateEntry> regions, final ServiceCallback<ImageRegionCreateSummaryInner> serviceCallback) {
        return ServiceFuture.fromResponse(createImageRegionsWithServiceResponseAsync(projectId, regions), serviceCallback);
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @param regions the List&lt;ImageRegionCreateEntry&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageRegionCreateSummaryInner object
     */
    public Observable<ImageRegionCreateSummaryInner> createImageRegionsAsync(UUID projectId, List<ImageRegionCreateEntry> regions) {
        return createImageRegionsWithServiceResponseAsync(projectId, regions).map(new Func1<ServiceResponse<ImageRegionCreateSummaryInner>, ImageRegionCreateSummaryInner>() {
            @Override
            public ImageRegionCreateSummaryInner call(ServiceResponse<ImageRegionCreateSummaryInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a set of image regions.
     * This API accepts a batch of image regions, and optionally tags, to update existing images with region information.
     There is a limit of 64 entries in the batch.
     *
     * @param projectId The project id
     * @param regions the List&lt;ImageRegionCreateEntry&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageRegionCreateSummaryInner object
     */
    public Observable<ServiceResponse<ImageRegionCreateSummaryInner>> createImageRegionsWithServiceResponseAsync(UUID projectId, List<ImageRegionCreateEntry> regions) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(regions);
        ImageRegionCreateBatch batch = new ImageRegionCreateBatch();
        batch.withRegions(regions);
        return service.createImageRegions(projectId, this.apiKey(), this.acceptLanguage(), batch, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageRegionCreateSummaryInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageRegionCreateSummaryInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageRegionCreateSummaryInner> clientResponse = createImageRegionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageRegionCreateSummaryInner> createImageRegionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageRegionCreateSummaryInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageRegionCreateSummaryInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a set of image regions.
     *
     * @param projectId The project id
     * @param regionIds Regions to delete. Limited to 64
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteImageRegions(UUID projectId, List<String> regionIds) {
        deleteImageRegionsWithServiceResponseAsync(projectId, regionIds).toBlocking().single().body();
    }

    /**
     * Delete a set of image regions.
     *
     * @param projectId The project id
     * @param regionIds Regions to delete. Limited to 64
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteImageRegionsAsync(UUID projectId, List<String> regionIds, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteImageRegionsWithServiceResponseAsync(projectId, regionIds), serviceCallback);
    }

    /**
     * Delete a set of image regions.
     *
     * @param projectId The project id
     * @param regionIds Regions to delete. Limited to 64
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteImageRegionsAsync(UUID projectId, List<String> regionIds) {
        return deleteImageRegionsWithServiceResponseAsync(projectId, regionIds).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a set of image regions.
     *
     * @param projectId The project id
     * @param regionIds Regions to delete. Limited to 64
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteImageRegionsWithServiceResponseAsync(UUID projectId, List<String> regionIds) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (regionIds == null) {
            throw new IllegalArgumentException("Parameter regionIds is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(regionIds);
        String regionIdsConverted = this.serializerAdapter().serializeList(regionIds, CollectionFormat.CSV);
        return service.deleteImageRegions(projectId, regionIdsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteImageRegionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteImageRegionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get region proposals for an image. Returns empty array if no proposals are found.
     * This API will get region proposals for an image along with confidences for the region. It returns an empty array if no proposals are found.
     *
     * @param projectId The project id
     * @param imageId The image id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImageRegionProposalInner object if successful.
     */
    public ImageRegionProposalInner getImageRegionProposals(UUID projectId, UUID imageId) {
        return getImageRegionProposalsWithServiceResponseAsync(projectId, imageId).toBlocking().single().body();
    }

    /**
     * Get region proposals for an image. Returns empty array if no proposals are found.
     * This API will get region proposals for an image along with confidences for the region. It returns an empty array if no proposals are found.
     *
     * @param projectId The project id
     * @param imageId The image id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImageRegionProposalInner> getImageRegionProposalsAsync(UUID projectId, UUID imageId, final ServiceCallback<ImageRegionProposalInner> serviceCallback) {
        return ServiceFuture.fromResponse(getImageRegionProposalsWithServiceResponseAsync(projectId, imageId), serviceCallback);
    }

    /**
     * Get region proposals for an image. Returns empty array if no proposals are found.
     * This API will get region proposals for an image along with confidences for the region. It returns an empty array if no proposals are found.
     *
     * @param projectId The project id
     * @param imageId The image id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageRegionProposalInner object
     */
    public Observable<ImageRegionProposalInner> getImageRegionProposalsAsync(UUID projectId, UUID imageId) {
        return getImageRegionProposalsWithServiceResponseAsync(projectId, imageId).map(new Func1<ServiceResponse<ImageRegionProposalInner>, ImageRegionProposalInner>() {
            @Override
            public ImageRegionProposalInner call(ServiceResponse<ImageRegionProposalInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get region proposals for an image. Returns empty array if no proposals are found.
     * This API will get region proposals for an image along with confidences for the region. It returns an empty array if no proposals are found.
     *
     * @param projectId The project id
     * @param imageId The image id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImageRegionProposalInner object
     */
    public Observable<ServiceResponse<ImageRegionProposalInner>> getImageRegionProposalsWithServiceResponseAsync(UUID projectId, UUID imageId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (imageId == null) {
            throw new IllegalArgumentException("Parameter imageId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getImageRegionProposals(projectId, imageId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImageRegionProposalInner>>>() {
                @Override
                public Observable<ServiceResponse<ImageRegionProposalInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImageRegionProposalInner> clientResponse = getImageRegionProposalsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImageRegionProposalInner> getImageRegionProposalsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImageRegionProposalInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImageRegionProposalInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a set of predicted images and their associated prediction results.
     *
     * @param projectId The project id
     * @param ids The prediction ids. Limited to 64
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletePrediction(UUID projectId, List<String> ids) {
        deletePredictionWithServiceResponseAsync(projectId, ids).toBlocking().single().body();
    }

    /**
     * Delete a set of predicted images and their associated prediction results.
     *
     * @param projectId The project id
     * @param ids The prediction ids. Limited to 64
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletePredictionAsync(UUID projectId, List<String> ids, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deletePredictionWithServiceResponseAsync(projectId, ids), serviceCallback);
    }

    /**
     * Delete a set of predicted images and their associated prediction results.
     *
     * @param projectId The project id
     * @param ids The prediction ids. Limited to 64
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deletePredictionAsync(UUID projectId, List<String> ids) {
        return deletePredictionWithServiceResponseAsync(projectId, ids).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a set of predicted images and their associated prediction results.
     *
     * @param projectId The project id
     * @param ids The prediction ids. Limited to 64
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deletePredictionWithServiceResponseAsync(UUID projectId, List<String> ids) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (ids == null) {
            throw new IllegalArgumentException("Parameter ids is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(ids);
        String idsConverted = this.serializerAdapter().serializeList(ids, CollectionFormat.CSV);
        return service.deletePrediction(projectId, idsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deletePredictionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deletePredictionDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get images that were sent to your prediction endpoint.
     *
     * @param projectId The project id
     * @param query Parameters used to query the predictions. Limited to combining 2 tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PredictionQueryResultInner object if successful.
     */
    public PredictionQueryResultInner queryPredictions(UUID projectId, PredictionQueryToken query) {
        return queryPredictionsWithServiceResponseAsync(projectId, query).toBlocking().single().body();
    }

    /**
     * Get images that were sent to your prediction endpoint.
     *
     * @param projectId The project id
     * @param query Parameters used to query the predictions. Limited to combining 2 tags
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PredictionQueryResultInner> queryPredictionsAsync(UUID projectId, PredictionQueryToken query, final ServiceCallback<PredictionQueryResultInner> serviceCallback) {
        return ServiceFuture.fromResponse(queryPredictionsWithServiceResponseAsync(projectId, query), serviceCallback);
    }

    /**
     * Get images that were sent to your prediction endpoint.
     *
     * @param projectId The project id
     * @param query Parameters used to query the predictions. Limited to combining 2 tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PredictionQueryResultInner object
     */
    public Observable<PredictionQueryResultInner> queryPredictionsAsync(UUID projectId, PredictionQueryToken query) {
        return queryPredictionsWithServiceResponseAsync(projectId, query).map(new Func1<ServiceResponse<PredictionQueryResultInner>, PredictionQueryResultInner>() {
            @Override
            public PredictionQueryResultInner call(ServiceResponse<PredictionQueryResultInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get images that were sent to your prediction endpoint.
     *
     * @param projectId The project id
     * @param query Parameters used to query the predictions. Limited to combining 2 tags
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PredictionQueryResultInner object
     */
    public Observable<ServiceResponse<PredictionQueryResultInner>> queryPredictionsWithServiceResponseAsync(UUID projectId, PredictionQueryToken query) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (query == null) {
            throw new IllegalArgumentException("Parameter query is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(query);
        return service.queryPredictions(projectId, query, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PredictionQueryResultInner>>>() {
                @Override
                public Observable<ServiceResponse<PredictionQueryResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PredictionQueryResultInner> clientResponse = queryPredictionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PredictionQueryResultInner> queryPredictionsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PredictionQueryResultInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PredictionQueryResultInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImagePredictionInner object if successful.
     */
    public ImagePredictionInner quickTestImageUrl(UUID projectId) {
        return quickTestImageUrlWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImagePredictionInner> quickTestImageUrlAsync(UUID projectId, final ServiceCallback<ImagePredictionInner> serviceCallback) {
        return ServiceFuture.fromResponse(quickTestImageUrlWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ImagePredictionInner> quickTestImageUrlAsync(UUID projectId) {
        return quickTestImageUrlWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<ImagePredictionInner>, ImagePredictionInner>() {
            @Override
            public ImagePredictionInner call(ServiceResponse<ImagePredictionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ServiceResponse<ImagePredictionInner>> quickTestImageUrlWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        final String url = null;
        ImageUrl imageUrl = new ImageUrl();
        imageUrl.withUrl(null);
        return service.quickTestImageUrl(projectId, iterationId, this.apiKey(), this.acceptLanguage(), imageUrl, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImagePredictionInner>>>() {
                @Override
                public Observable<ServiceResponse<ImagePredictionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImagePredictionInner> clientResponse = quickTestImageUrlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @param url the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImagePredictionInner object if successful.
     */
    public ImagePredictionInner quickTestImageUrl(UUID projectId, UUID iterationId, String url) {
        return quickTestImageUrlWithServiceResponseAsync(projectId, iterationId, url).toBlocking().single().body();
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @param url the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImagePredictionInner> quickTestImageUrlAsync(UUID projectId, UUID iterationId, String url, final ServiceCallback<ImagePredictionInner> serviceCallback) {
        return ServiceFuture.fromResponse(quickTestImageUrlWithServiceResponseAsync(projectId, iterationId, url), serviceCallback);
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @param url the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ImagePredictionInner> quickTestImageUrlAsync(UUID projectId, UUID iterationId, String url) {
        return quickTestImageUrlWithServiceResponseAsync(projectId, iterationId, url).map(new Func1<ServiceResponse<ImagePredictionInner>, ImagePredictionInner>() {
            @Override
            public ImagePredictionInner call(ServiceResponse<ImagePredictionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Quick test an image url.
     *
     * @param projectId The project to evaluate against
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @param url the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ServiceResponse<ImagePredictionInner>> quickTestImageUrlWithServiceResponseAsync(UUID projectId, UUID iterationId, String url) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        ImageUrl imageUrl = new ImageUrl();
        imageUrl.withUrl(url);
        return service.quickTestImageUrl(projectId, iterationId, this.apiKey(), this.acceptLanguage(), imageUrl, this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImagePredictionInner>>>() {
                @Override
                public Observable<ServiceResponse<ImagePredictionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImagePredictionInner> clientResponse = quickTestImageUrlDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImagePredictionInner> quickTestImageUrlDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImagePredictionInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImagePredictionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImagePredictionInner object if successful.
     */
    public ImagePredictionInner quickTestImage(UUID projectId, byte[] imageData) {
        return quickTestImageWithServiceResponseAsync(projectId, imageData).toBlocking().single().body();
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImagePredictionInner> quickTestImageAsync(UUID projectId, byte[] imageData, final ServiceCallback<ImagePredictionInner> serviceCallback) {
        return ServiceFuture.fromResponse(quickTestImageWithServiceResponseAsync(projectId, imageData), serviceCallback);
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ImagePredictionInner> quickTestImageAsync(UUID projectId, byte[] imageData) {
        return quickTestImageWithServiceResponseAsync(projectId, imageData).map(new Func1<ServiceResponse<ImagePredictionInner>, ImagePredictionInner>() {
            @Override
            public ImagePredictionInner call(ServiceResponse<ImagePredictionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ServiceResponse<ImagePredictionInner>> quickTestImageWithServiceResponseAsync(UUID projectId, byte[] imageData) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (imageData == null) {
            throw new IllegalArgumentException("Parameter imageData is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        RequestBody imageDataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), imageData);
        return service.quickTestImage(projectId, iterationId, imageDataConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImagePredictionInner>>>() {
                @Override
                public Observable<ServiceResponse<ImagePredictionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImagePredictionInner> clientResponse = quickTestImageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ImagePredictionInner object if successful.
     */
    public ImagePredictionInner quickTestImage(UUID projectId, byte[] imageData, UUID iterationId) {
        return quickTestImageWithServiceResponseAsync(projectId, imageData, iterationId).toBlocking().single().body();
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ImagePredictionInner> quickTestImageAsync(UUID projectId, byte[] imageData, UUID iterationId, final ServiceCallback<ImagePredictionInner> serviceCallback) {
        return ServiceFuture.fromResponse(quickTestImageWithServiceResponseAsync(projectId, imageData, iterationId), serviceCallback);
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ImagePredictionInner> quickTestImageAsync(UUID projectId, byte[] imageData, UUID iterationId) {
        return quickTestImageWithServiceResponseAsync(projectId, imageData, iterationId).map(new Func1<ServiceResponse<ImagePredictionInner>, ImagePredictionInner>() {
            @Override
            public ImagePredictionInner call(ServiceResponse<ImagePredictionInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Quick test an image.
     *
     * @param projectId The project id
     * @param imageData the InputStream value
     * @param iterationId Optional. Specifies the id of a particular iteration to evaluate against.
                 The default iteration for the project will be used when not specified.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ImagePredictionInner object
     */
    public Observable<ServiceResponse<ImagePredictionInner>> quickTestImageWithServiceResponseAsync(UUID projectId, byte[] imageData, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (imageData == null) {
            throw new IllegalArgumentException("Parameter imageData is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        RequestBody imageDataConverted = RequestBody.create(MediaType.parse("multipart/form-data"), imageData);
        return service.quickTestImage(projectId, iterationId, imageDataConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ImagePredictionInner>>>() {
                @Override
                public Observable<ServiceResponse<ImagePredictionInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ImagePredictionInner> clientResponse = quickTestImageDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ImagePredictionInner> quickTestImageDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ImagePredictionInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ImagePredictionInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Queues project for training.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IterationInner object if successful.
     */
    public IterationInner trainProject(UUID projectId) {
        return trainProjectWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Queues project for training.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IterationInner> trainProjectAsync(UUID projectId, final ServiceCallback<IterationInner> serviceCallback) {
        return ServiceFuture.fromResponse(trainProjectWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Queues project for training.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationInner object
     */
    public Observable<IterationInner> trainProjectAsync(UUID projectId) {
        return trainProjectWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<IterationInner>, IterationInner>() {
            @Override
            public IterationInner call(ServiceResponse<IterationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Queues project for training.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationInner object
     */
    public Observable<ServiceResponse<IterationInner>> trainProjectWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.trainProject(projectId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IterationInner>>>() {
                @Override
                public Observable<ServiceResponse<IterationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IterationInner> clientResponse = trainProjectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IterationInner> trainProjectDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IterationInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IterationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get your projects.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ProjectInner&gt; object if successful.
     */
    public List<ProjectInner> getProjects() {
        return getProjectsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get your projects.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ProjectInner>> getProjectsAsync(final ServiceCallback<List<ProjectInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getProjectsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get your projects.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ProjectInner&gt; object
     */
    public Observable<List<ProjectInner>> getProjectsAsync() {
        return getProjectsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ProjectInner>>, List<ProjectInner>>() {
            @Override
            public List<ProjectInner> call(ServiceResponse<List<ProjectInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get your projects.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ProjectInner&gt; object
     */
    public Observable<ServiceResponse<List<ProjectInner>>> getProjectsWithServiceResponseAsync() {
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getProjects(this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ProjectInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ProjectInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ProjectInner>> clientResponse = getProjectsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ProjectInner>> getProjectsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ProjectInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ProjectInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProjectInner object if successful.
     */
    public ProjectInner createProject(String name) {
        return createProjectWithServiceResponseAsync(name).toBlocking().single().body();
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProjectInner> createProjectAsync(String name, final ServiceCallback<ProjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(createProjectWithServiceResponseAsync(name), serviceCallback);
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ProjectInner> createProjectAsync(String name) {
        return createProjectWithServiceResponseAsync(name).map(new Func1<ServiceResponse<ProjectInner>, ProjectInner>() {
            @Override
            public ProjectInner call(ServiceResponse<ProjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ServiceResponse<ProjectInner>> createProjectWithServiceResponseAsync(String name) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final String description = null;
        final UUID domainId = null;
        return service.createProject(name, description, domainId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProjectInner>>>() {
                @Override
                public Observable<ServiceResponse<ProjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProjectInner> clientResponse = createProjectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @param description The description of the project
     * @param domainId The id of the domain to use for this project. Defaults to General
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProjectInner object if successful.
     */
    public ProjectInner createProject(String name, String description, UUID domainId) {
        return createProjectWithServiceResponseAsync(name, description, domainId).toBlocking().single().body();
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @param description The description of the project
     * @param domainId The id of the domain to use for this project. Defaults to General
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProjectInner> createProjectAsync(String name, String description, UUID domainId, final ServiceCallback<ProjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(createProjectWithServiceResponseAsync(name, description, domainId), serviceCallback);
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @param description The description of the project
     * @param domainId The id of the domain to use for this project. Defaults to General
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ProjectInner> createProjectAsync(String name, String description, UUID domainId) {
        return createProjectWithServiceResponseAsync(name, description, domainId).map(new Func1<ServiceResponse<ProjectInner>, ProjectInner>() {
            @Override
            public ProjectInner call(ServiceResponse<ProjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a project.
     *
     * @param name Name of the project
     * @param description The description of the project
     * @param domainId The id of the domain to use for this project. Defaults to General
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ServiceResponse<ProjectInner>> createProjectWithServiceResponseAsync(String name, String description, UUID domainId) {
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.createProject(name, description, domainId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProjectInner>>>() {
                @Override
                public Observable<ServiceResponse<ProjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProjectInner> clientResponse = createProjectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProjectInner> createProjectDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ProjectInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ProjectInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a specific project.
     *
     * @param projectId The id of the project to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProjectInner object if successful.
     */
    public ProjectInner getProject(UUID projectId) {
        return getProjectWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Get a specific project.
     *
     * @param projectId The id of the project to get
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProjectInner> getProjectAsync(UUID projectId, final ServiceCallback<ProjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(getProjectWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Get a specific project.
     *
     * @param projectId The id of the project to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ProjectInner> getProjectAsync(UUID projectId) {
        return getProjectWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<ProjectInner>, ProjectInner>() {
            @Override
            public ProjectInner call(ServiceResponse<ProjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a specific project.
     *
     * @param projectId The id of the project to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ServiceResponse<ProjectInner>> getProjectWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getProject(projectId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProjectInner>>>() {
                @Override
                public Observable<ServiceResponse<ProjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProjectInner> clientResponse = getProjectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProjectInner> getProjectDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ProjectInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ProjectInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a specific project.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteProject(UUID projectId) {
        deleteProjectWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Delete a specific project.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteProjectAsync(UUID projectId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteProjectWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Delete a specific project.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteProjectAsync(UUID projectId) {
        return deleteProjectWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a specific project.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteProjectWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.deleteProject(projectId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteProjectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteProjectDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update a specific project.
     *
     * @param projectId The id of the project to update
     * @param updatedProject The updated project model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProjectInner object if successful.
     */
    public ProjectInner updateProject(UUID projectId, ProjectInner updatedProject) {
        return updateProjectWithServiceResponseAsync(projectId, updatedProject).toBlocking().single().body();
    }

    /**
     * Update a specific project.
     *
     * @param projectId The id of the project to update
     * @param updatedProject The updated project model
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProjectInner> updateProjectAsync(UUID projectId, ProjectInner updatedProject, final ServiceCallback<ProjectInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateProjectWithServiceResponseAsync(projectId, updatedProject), serviceCallback);
    }

    /**
     * Update a specific project.
     *
     * @param projectId The id of the project to update
     * @param updatedProject The updated project model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ProjectInner> updateProjectAsync(UUID projectId, ProjectInner updatedProject) {
        return updateProjectWithServiceResponseAsync(projectId, updatedProject).map(new Func1<ServiceResponse<ProjectInner>, ProjectInner>() {
            @Override
            public ProjectInner call(ServiceResponse<ProjectInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a specific project.
     *
     * @param projectId The id of the project to update
     * @param updatedProject The updated project model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ProjectInner object
     */
    public Observable<ServiceResponse<ProjectInner>> updateProjectWithServiceResponseAsync(UUID projectId, ProjectInner updatedProject) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (updatedProject == null) {
            throw new IllegalArgumentException("Parameter updatedProject is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(updatedProject);
        return service.updateProject(projectId, updatedProject, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ProjectInner>>>() {
                @Override
                public Observable<ServiceResponse<ProjectInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ProjectInner> clientResponse = updateProjectDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ProjectInner> updateProjectDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ProjectInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ProjectInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get iterations for the project.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;IterationInner&gt; object if successful.
     */
    public List<IterationInner> getIterations(UUID projectId) {
        return getIterationsWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Get iterations for the project.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IterationInner>> getIterationsAsync(UUID projectId, final ServiceCallback<List<IterationInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getIterationsWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Get iterations for the project.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IterationInner&gt; object
     */
    public Observable<List<IterationInner>> getIterationsAsync(UUID projectId) {
        return getIterationsWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<List<IterationInner>>, List<IterationInner>>() {
            @Override
            public List<IterationInner> call(ServiceResponse<List<IterationInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get iterations for the project.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IterationInner&gt; object
     */
    public Observable<ServiceResponse<List<IterationInner>>> getIterationsWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getIterations(projectId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<IterationInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<IterationInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<IterationInner>> clientResponse = getIterationsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<IterationInner>> getIterationsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<IterationInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<IterationInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get a specific iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IterationInner object if successful.
     */
    public IterationInner getIteration(UUID projectId, UUID iterationId) {
        return getIterationWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Get a specific iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IterationInner> getIterationAsync(UUID projectId, UUID iterationId, final ServiceCallback<IterationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getIterationWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Get a specific iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationInner object
     */
    public Observable<IterationInner> getIterationAsync(UUID projectId, UUID iterationId) {
        return getIterationWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<IterationInner>, IterationInner>() {
            @Override
            public IterationInner call(ServiceResponse<IterationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a specific iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationInner object
     */
    public Observable<ServiceResponse<IterationInner>> getIterationWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getIteration(projectId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IterationInner>>>() {
                @Override
                public Observable<ServiceResponse<IterationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IterationInner> clientResponse = getIterationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IterationInner> getIterationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IterationInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IterationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a specific iteration of a project.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteIteration(UUID projectId, UUID iterationId) {
        deleteIterationWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Delete a specific iteration of a project.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteIterationAsync(UUID projectId, UUID iterationId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteIterationWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Delete a specific iteration of a project.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteIterationAsync(UUID projectId, UUID iterationId) {
        return deleteIterationWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a specific iteration of a project.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteIterationWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.deleteIteration(projectId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteIterationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteIterationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update a specific iteration.
     *
     * @param projectId Project id
     * @param iterationId Iteration id
     * @param updatedIteration The updated iteration model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IterationInner object if successful.
     */
    public IterationInner updateIteration(UUID projectId, UUID iterationId, IterationInner updatedIteration) {
        return updateIterationWithServiceResponseAsync(projectId, iterationId, updatedIteration).toBlocking().single().body();
    }

    /**
     * Update a specific iteration.
     *
     * @param projectId Project id
     * @param iterationId Iteration id
     * @param updatedIteration The updated iteration model
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IterationInner> updateIterationAsync(UUID projectId, UUID iterationId, IterationInner updatedIteration, final ServiceCallback<IterationInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateIterationWithServiceResponseAsync(projectId, iterationId, updatedIteration), serviceCallback);
    }

    /**
     * Update a specific iteration.
     *
     * @param projectId Project id
     * @param iterationId Iteration id
     * @param updatedIteration The updated iteration model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationInner object
     */
    public Observable<IterationInner> updateIterationAsync(UUID projectId, UUID iterationId, IterationInner updatedIteration) {
        return updateIterationWithServiceResponseAsync(projectId, iterationId, updatedIteration).map(new Func1<ServiceResponse<IterationInner>, IterationInner>() {
            @Override
            public IterationInner call(ServiceResponse<IterationInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a specific iteration.
     *
     * @param projectId Project id
     * @param iterationId Iteration id
     * @param updatedIteration The updated iteration model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationInner object
     */
    public Observable<ServiceResponse<IterationInner>> updateIterationWithServiceResponseAsync(UUID projectId, UUID iterationId, IterationInner updatedIteration) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (updatedIteration == null) {
            throw new IllegalArgumentException("Parameter updatedIteration is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(updatedIteration);
        return service.updateIteration(projectId, iterationId, updatedIteration, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IterationInner>>>() {
                @Override
                public Observable<ServiceResponse<IterationInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IterationInner> clientResponse = updateIterationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IterationInner> updateIterationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IterationInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IterationInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IterationPerformanceInner object if successful.
     */
    public IterationPerformanceInner getIterationPerformance(UUID projectId, UUID iterationId) {
        return getIterationPerformanceWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IterationPerformanceInner> getIterationPerformanceAsync(UUID projectId, UUID iterationId, final ServiceCallback<IterationPerformanceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getIterationPerformanceWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationPerformanceInner object
     */
    public Observable<IterationPerformanceInner> getIterationPerformanceAsync(UUID projectId, UUID iterationId) {
        return getIterationPerformanceWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<IterationPerformanceInner>, IterationPerformanceInner>() {
            @Override
            public IterationPerformanceInner call(ServiceResponse<IterationPerformanceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationPerformanceInner object
     */
    public Observable<ServiceResponse<IterationPerformanceInner>> getIterationPerformanceWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final Double threshold = null;
        final Double overlapThreshold = null;
        return service.getIterationPerformance(projectId, iterationId, threshold, overlapThreshold, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IterationPerformanceInner>>>() {
                @Override
                public Observable<ServiceResponse<IterationPerformanceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IterationPerformanceInner> clientResponse = getIterationPerformanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @param threshold The threshold used to determine true predictions
     * @param overlapThreshold If applicable, the bounding box overlap threshold used to determine true predictions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IterationPerformanceInner object if successful.
     */
    public IterationPerformanceInner getIterationPerformance(UUID projectId, UUID iterationId, Double threshold, Double overlapThreshold) {
        return getIterationPerformanceWithServiceResponseAsync(projectId, iterationId, threshold, overlapThreshold).toBlocking().single().body();
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @param threshold The threshold used to determine true predictions
     * @param overlapThreshold If applicable, the bounding box overlap threshold used to determine true predictions
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IterationPerformanceInner> getIterationPerformanceAsync(UUID projectId, UUID iterationId, Double threshold, Double overlapThreshold, final ServiceCallback<IterationPerformanceInner> serviceCallback) {
        return ServiceFuture.fromResponse(getIterationPerformanceWithServiceResponseAsync(projectId, iterationId, threshold, overlapThreshold), serviceCallback);
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @param threshold The threshold used to determine true predictions
     * @param overlapThreshold If applicable, the bounding box overlap threshold used to determine true predictions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationPerformanceInner object
     */
    public Observable<IterationPerformanceInner> getIterationPerformanceAsync(UUID projectId, UUID iterationId, Double threshold, Double overlapThreshold) {
        return getIterationPerformanceWithServiceResponseAsync(projectId, iterationId, threshold, overlapThreshold).map(new Func1<ServiceResponse<IterationPerformanceInner>, IterationPerformanceInner>() {
            @Override
            public IterationPerformanceInner call(ServiceResponse<IterationPerformanceInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get detailed performance information about an iteration.
     *
     * @param projectId The id of the project the iteration belongs to
     * @param iterationId The id of the iteration to get
     * @param threshold The threshold used to determine true predictions
     * @param overlapThreshold If applicable, the bounding box overlap threshold used to determine true predictions
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IterationPerformanceInner object
     */
    public Observable<ServiceResponse<IterationPerformanceInner>> getIterationPerformanceWithServiceResponseAsync(UUID projectId, UUID iterationId, Double threshold, Double overlapThreshold) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getIterationPerformance(projectId, iterationId, threshold, overlapThreshold, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IterationPerformanceInner>>>() {
                @Override
                public Observable<ServiceResponse<IterationPerformanceInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IterationPerformanceInner> clientResponse = getIterationPerformanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IterationPerformanceInner> getIterationPerformanceDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<IterationPerformanceInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IterationPerformanceInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImagePerformanceInner&gt; object if successful.
     */
    public List<ImagePerformanceInner> getImagePerformances(UUID projectId, UUID iterationId) {
        return getImagePerformancesWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImagePerformanceInner>> getImagePerformancesAsync(UUID projectId, UUID iterationId, final ServiceCallback<List<ImagePerformanceInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getImagePerformancesWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImagePerformanceInner&gt; object
     */
    public Observable<List<ImagePerformanceInner>> getImagePerformancesAsync(UUID projectId, UUID iterationId) {
        return getImagePerformancesWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<List<ImagePerformanceInner>>, List<ImagePerformanceInner>>() {
            @Override
            public List<ImagePerformanceInner> call(ServiceResponse<List<ImagePerformanceInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImagePerformanceInner&gt; object
     */
    public Observable<ServiceResponse<List<ImagePerformanceInner>>> getImagePerformancesWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final List<String> tagIds = null;
        final String orderBy = null;
        final Integer take = null;
        final Integer skip = null;
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getImagePerformances(projectId, iterationId, tagIdsConverted, orderBy, take, skip, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImagePerformanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImagePerformanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImagePerformanceInner>> clientResponse = getImagePerformancesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ImagePerformanceInner&gt; object if successful.
     */
    public List<ImagePerformanceInner> getImagePerformances(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip) {
        return getImagePerformancesWithServiceResponseAsync(projectId, iterationId, tagIds, orderBy, take, skip).toBlocking().single().body();
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ImagePerformanceInner>> getImagePerformancesAsync(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip, final ServiceCallback<List<ImagePerformanceInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getImagePerformancesWithServiceResponseAsync(projectId, iterationId, tagIds, orderBy, take, skip), serviceCallback);
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImagePerformanceInner&gt; object
     */
    public Observable<List<ImagePerformanceInner>> getImagePerformancesAsync(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip) {
        return getImagePerformancesWithServiceResponseAsync(projectId, iterationId, tagIds, orderBy, take, skip).map(new Func1<ServiceResponse<List<ImagePerformanceInner>>, List<ImagePerformanceInner>>() {
            @Override
            public List<ImagePerformanceInner> call(ServiceResponse<List<ImagePerformanceInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get image with its prediction for a given project iteration.
     * This API supports batching and range selection. By default it will only return first 50 images matching images.
     Use the {take} and {skip} parameters to control how many images to return in a given batch.
     The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images. Defaults to all tagged images when null. Limited to 20
     * @param orderBy The ordering. Defaults to newest. Possible values include: 'Newest', 'Oldest'
     * @param take Maximum number of images to return. Defaults to 50, limited to 256
     * @param skip Number of images to skip before beginning the image batch. Defaults to 0
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ImagePerformanceInner&gt; object
     */
    public Observable<ServiceResponse<List<ImagePerformanceInner>>> getImagePerformancesWithServiceResponseAsync(UUID projectId, UUID iterationId, List<String> tagIds, String orderBy, Integer take, Integer skip) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(tagIds);
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getImagePerformances(projectId, iterationId, tagIdsConverted, orderBy, take, skip, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ImagePerformanceInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ImagePerformanceInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ImagePerformanceInner>> clientResponse = getImagePerformancesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ImagePerformanceInner>> getImagePerformancesDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ImagePerformanceInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ImagePerformanceInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int getImagePerformanceCount(UUID projectId, UUID iterationId) {
        return getImagePerformanceCountWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> getImagePerformanceCountAsync(UUID projectId, UUID iterationId, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(getImagePerformanceCountWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> getImagePerformanceCountAsync(UUID projectId, UUID iterationId) {
        return getImagePerformanceCountWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> getImagePerformanceCountWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final List<String> tagIds = null;
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getImagePerformanceCount(projectId, iterationId, tagIdsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = getImagePerformanceCountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int getImagePerformanceCount(UUID projectId, UUID iterationId, List<String> tagIds) {
        return getImagePerformanceCountWithServiceResponseAsync(projectId, iterationId, tagIds).toBlocking().single().body();
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> getImagePerformanceCountAsync(UUID projectId, UUID iterationId, List<String> tagIds, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(getImagePerformanceCountWithServiceResponseAsync(projectId, iterationId, tagIds), serviceCallback);
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> getImagePerformanceCountAsync(UUID projectId, UUID iterationId, List<String> tagIds) {
        return getImagePerformanceCountWithServiceResponseAsync(projectId, iterationId, tagIds).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the number of images tagged with the provided {tagIds} that have prediction results from
     training for the provided iteration {iterationId}.
     * The filtering is on an and/or relationship. For example, if the provided tag ids are for the "Dog" and
     "Cat" tags, then only images tagged with Dog and/or Cat will be returned.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param tagIds A list of tags ids to filter the images to count. Defaults to all tags when null.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> getImagePerformanceCountWithServiceResponseAsync(UUID projectId, UUID iterationId, List<String> tagIds) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(tagIds);
        String tagIdsConverted = this.serializerAdapter().serializeList(tagIds, CollectionFormat.CSV);
        return service.getImagePerformanceCount(projectId, iterationId, tagIdsConverted, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = getImagePerformanceCountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Integer> getImagePerformanceCountDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Integer, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Integer>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the list of exports for a specific iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ExportInner&gt; object if successful.
     */
    public List<ExportInner> getExports(UUID projectId, UUID iterationId) {
        return getExportsWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Get the list of exports for a specific iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ExportInner>> getExportsAsync(UUID projectId, UUID iterationId, final ServiceCallback<List<ExportInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getExportsWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Get the list of exports for a specific iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExportInner&gt; object
     */
    public Observable<List<ExportInner>> getExportsAsync(UUID projectId, UUID iterationId) {
        return getExportsWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<List<ExportInner>>, List<ExportInner>>() {
            @Override
            public List<ExportInner> call(ServiceResponse<List<ExportInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the list of exports for a specific iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ExportInner&gt; object
     */
    public Observable<ServiceResponse<List<ExportInner>>> getExportsWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getExports(projectId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ExportInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ExportInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ExportInner>> clientResponse = getExportsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ExportInner>> getExportsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ExportInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ExportInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ExportInner object if successful.
     */
    public ExportInner exportIteration(UUID projectId, UUID iterationId, String platform) {
        return exportIterationWithServiceResponseAsync(projectId, iterationId, platform).toBlocking().single().body();
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ExportInner> exportIterationAsync(UUID projectId, UUID iterationId, String platform, final ServiceCallback<ExportInner> serviceCallback) {
        return ServiceFuture.fromResponse(exportIterationWithServiceResponseAsync(projectId, iterationId, platform), serviceCallback);
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ExportInner object
     */
    public Observable<ExportInner> exportIterationAsync(UUID projectId, UUID iterationId, String platform) {
        return exportIterationWithServiceResponseAsync(projectId, iterationId, platform).map(new Func1<ServiceResponse<ExportInner>, ExportInner>() {
            @Override
            public ExportInner call(ServiceResponse<ExportInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ExportInner object
     */
    public Observable<ServiceResponse<ExportInner>> exportIterationWithServiceResponseAsync(UUID projectId, UUID iterationId, String platform) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (platform == null) {
            throw new IllegalArgumentException("Parameter platform is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final String flavor = null;
        return service.exportIteration(projectId, iterationId, platform, flavor, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ExportInner>>>() {
                @Override
                public Observable<ServiceResponse<ExportInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ExportInner> clientResponse = exportIterationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @param flavor The flavor of the target platform (Windows, Linux, ARM, or GPU)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ExportInner object if successful.
     */
    public ExportInner exportIteration(UUID projectId, UUID iterationId, String platform, String flavor) {
        return exportIterationWithServiceResponseAsync(projectId, iterationId, platform, flavor).toBlocking().single().body();
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @param flavor The flavor of the target platform (Windows, Linux, ARM, or GPU)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ExportInner> exportIterationAsync(UUID projectId, UUID iterationId, String platform, String flavor, final ServiceCallback<ExportInner> serviceCallback) {
        return ServiceFuture.fromResponse(exportIterationWithServiceResponseAsync(projectId, iterationId, platform, flavor), serviceCallback);
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @param flavor The flavor of the target platform (Windows, Linux, ARM, or GPU)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ExportInner object
     */
    public Observable<ExportInner> exportIterationAsync(UUID projectId, UUID iterationId, String platform, String flavor) {
        return exportIterationWithServiceResponseAsync(projectId, iterationId, platform, flavor).map(new Func1<ServiceResponse<ExportInner>, ExportInner>() {
            @Override
            public ExportInner call(ServiceResponse<ExportInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Export a trained iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id
     * @param platform The target platform (coreml or tensorflow)
     * @param flavor The flavor of the target platform (Windows, Linux, ARM, or GPU)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ExportInner object
     */
    public Observable<ServiceResponse<ExportInner>> exportIterationWithServiceResponseAsync(UUID projectId, UUID iterationId, String platform, String flavor) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (iterationId == null) {
            throw new IllegalArgumentException("Parameter iterationId is required and cannot be null.");
        }
        if (platform == null) {
            throw new IllegalArgumentException("Parameter platform is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.exportIteration(projectId, iterationId, platform, flavor, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ExportInner>>>() {
                @Override
                public Observable<ServiceResponse<ExportInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ExportInner> clientResponse = exportIterationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ExportInner> exportIterationDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ExportInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ExportInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TagInner object if successful.
     */
    public TagInner getTag(UUID projectId, UUID tagId) {
        return getTagWithServiceResponseAsync(projectId, tagId).toBlocking().single().body();
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TagInner> getTagAsync(UUID projectId, UUID tagId, final ServiceCallback<TagInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTagWithServiceResponseAsync(projectId, tagId), serviceCallback);
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<TagInner> getTagAsync(UUID projectId, UUID tagId) {
        return getTagWithServiceResponseAsync(projectId, tagId).map(new Func1<ServiceResponse<TagInner>, TagInner>() {
            @Override
            public TagInner call(ServiceResponse<TagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<ServiceResponse<TagInner>> getTagWithServiceResponseAsync(UUID projectId, UUID tagId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (tagId == null) {
            throw new IllegalArgumentException("Parameter tagId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        return service.getTag(projectId, tagId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TagInner>>>() {
                @Override
                public Observable<ServiceResponse<TagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TagInner> clientResponse = getTagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @param iterationId The iteration to retrieve this tag from. Optional, defaults to current training set
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TagInner object if successful.
     */
    public TagInner getTag(UUID projectId, UUID tagId, UUID iterationId) {
        return getTagWithServiceResponseAsync(projectId, tagId, iterationId).toBlocking().single().body();
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @param iterationId The iteration to retrieve this tag from. Optional, defaults to current training set
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TagInner> getTagAsync(UUID projectId, UUID tagId, UUID iterationId, final ServiceCallback<TagInner> serviceCallback) {
        return ServiceFuture.fromResponse(getTagWithServiceResponseAsync(projectId, tagId, iterationId), serviceCallback);
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @param iterationId The iteration to retrieve this tag from. Optional, defaults to current training set
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<TagInner> getTagAsync(UUID projectId, UUID tagId, UUID iterationId) {
        return getTagWithServiceResponseAsync(projectId, tagId, iterationId).map(new Func1<ServiceResponse<TagInner>, TagInner>() {
            @Override
            public TagInner call(ServiceResponse<TagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get information about a specific tag.
     *
     * @param projectId The project this tag belongs to
     * @param tagId The tag id
     * @param iterationId The iteration to retrieve this tag from. Optional, defaults to current training set
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<ServiceResponse<TagInner>> getTagWithServiceResponseAsync(UUID projectId, UUID tagId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (tagId == null) {
            throw new IllegalArgumentException("Parameter tagId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getTag(projectId, tagId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TagInner>>>() {
                @Override
                public Observable<ServiceResponse<TagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TagInner> clientResponse = getTagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TagInner> getTagDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TagInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TagInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Delete a tag from the project.
     *
     * @param projectId The project id
     * @param tagId Id of the tag to be deleted
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deleteTag(UUID projectId, UUID tagId) {
        deleteTagWithServiceResponseAsync(projectId, tagId).toBlocking().single().body();
    }

    /**
     * Delete a tag from the project.
     *
     * @param projectId The project id
     * @param tagId Id of the tag to be deleted
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteTagAsync(UUID projectId, UUID tagId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(deleteTagWithServiceResponseAsync(projectId, tagId), serviceCallback);
    }

    /**
     * Delete a tag from the project.
     *
     * @param projectId The project id
     * @param tagId Id of the tag to be deleted
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> deleteTagAsync(UUID projectId, UUID tagId) {
        return deleteTagWithServiceResponseAsync(projectId, tagId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Delete a tag from the project.
     *
     * @param projectId The project id
     * @param tagId Id of the tag to be deleted
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> deleteTagWithServiceResponseAsync(UUID projectId, UUID tagId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (tagId == null) {
            throw new IllegalArgumentException("Parameter tagId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.deleteTag(projectId, tagId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = deleteTagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> deleteTagDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Update a tag.
     *
     * @param projectId The project id
     * @param tagId The id of the target tag
     * @param updatedTag The updated tag model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TagInner object if successful.
     */
    public TagInner updateTag(UUID projectId, UUID tagId, TagInner updatedTag) {
        return updateTagWithServiceResponseAsync(projectId, tagId, updatedTag).toBlocking().single().body();
    }

    /**
     * Update a tag.
     *
     * @param projectId The project id
     * @param tagId The id of the target tag
     * @param updatedTag The updated tag model
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TagInner> updateTagAsync(UUID projectId, UUID tagId, TagInner updatedTag, final ServiceCallback<TagInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateTagWithServiceResponseAsync(projectId, tagId, updatedTag), serviceCallback);
    }

    /**
     * Update a tag.
     *
     * @param projectId The project id
     * @param tagId The id of the target tag
     * @param updatedTag The updated tag model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<TagInner> updateTagAsync(UUID projectId, UUID tagId, TagInner updatedTag) {
        return updateTagWithServiceResponseAsync(projectId, tagId, updatedTag).map(new Func1<ServiceResponse<TagInner>, TagInner>() {
            @Override
            public TagInner call(ServiceResponse<TagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Update a tag.
     *
     * @param projectId The project id
     * @param tagId The id of the target tag
     * @param updatedTag The updated tag model
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<ServiceResponse<TagInner>> updateTagWithServiceResponseAsync(UUID projectId, UUID tagId, TagInner updatedTag) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (tagId == null) {
            throw new IllegalArgumentException("Parameter tagId is required and cannot be null.");
        }
        if (updatedTag == null) {
            throw new IllegalArgumentException("Parameter updatedTag is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        Validator.validate(updatedTag);
        return service.updateTag(projectId, tagId, updatedTag, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TagInner>>>() {
                @Override
                public Observable<ServiceResponse<TagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TagInner> clientResponse = updateTagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TagInner> updateTagDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TagInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TagInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;TagInner&gt; object if successful.
     */
    public List<TagInner> getTags(UUID projectId) {
        return getTagsWithServiceResponseAsync(projectId).toBlocking().single().body();
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TagInner>> getTagsAsync(UUID projectId, final ServiceCallback<List<TagInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getTagsWithServiceResponseAsync(projectId), serviceCallback);
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TagInner&gt; object
     */
    public Observable<List<TagInner>> getTagsAsync(UUID projectId) {
        return getTagsWithServiceResponseAsync(projectId).map(new Func1<ServiceResponse<List<TagInner>>, List<TagInner>>() {
            @Override
            public List<TagInner> call(ServiceResponse<List<TagInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TagInner&gt; object
     */
    public Observable<ServiceResponse<List<TagInner>>> getTagsWithServiceResponseAsync(UUID projectId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final UUID iterationId = null;
        return service.getTags(projectId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<TagInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<TagInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<TagInner>> clientResponse = getTagsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;TagInner&gt; object if successful.
     */
    public List<TagInner> getTags(UUID projectId, UUID iterationId) {
        return getTagsWithServiceResponseAsync(projectId, iterationId).toBlocking().single().body();
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TagInner>> getTagsAsync(UUID projectId, UUID iterationId, final ServiceCallback<List<TagInner>> serviceCallback) {
        return ServiceFuture.fromResponse(getTagsWithServiceResponseAsync(projectId, iterationId), serviceCallback);
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TagInner&gt; object
     */
    public Observable<List<TagInner>> getTagsAsync(UUID projectId, UUID iterationId) {
        return getTagsWithServiceResponseAsync(projectId, iterationId).map(new Func1<ServiceResponse<List<TagInner>>, List<TagInner>>() {
            @Override
            public List<TagInner> call(ServiceResponse<List<TagInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get the tags for a given project and iteration.
     *
     * @param projectId The project id
     * @param iterationId The iteration id. Defaults to workspace
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TagInner&gt; object
     */
    public Observable<ServiceResponse<List<TagInner>>> getTagsWithServiceResponseAsync(UUID projectId, UUID iterationId) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.getTags(projectId, iterationId, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<TagInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<TagInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<TagInner>> clientResponse = getTagsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<TagInner>> getTagsDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<TagInner>, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<TagInner>>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TagInner object if successful.
     */
    public TagInner createTag(UUID projectId, String name) {
        return createTagWithServiceResponseAsync(projectId, name).toBlocking().single().body();
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TagInner> createTagAsync(UUID projectId, String name, final ServiceCallback<TagInner> serviceCallback) {
        return ServiceFuture.fromResponse(createTagWithServiceResponseAsync(projectId, name), serviceCallback);
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<TagInner> createTagAsync(UUID projectId, String name) {
        return createTagWithServiceResponseAsync(projectId, name).map(new Func1<ServiceResponse<TagInner>, TagInner>() {
            @Override
            public TagInner call(ServiceResponse<TagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<ServiceResponse<TagInner>> createTagWithServiceResponseAsync(UUID projectId, String name) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        final String description = null;
        return service.createTag(projectId, name, description, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TagInner>>>() {
                @Override
                public Observable<ServiceResponse<TagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TagInner> clientResponse = createTagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @param description Optional description for the tag
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TagInner object if successful.
     */
    public TagInner createTag(UUID projectId, String name, String description) {
        return createTagWithServiceResponseAsync(projectId, name, description).toBlocking().single().body();
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @param description Optional description for the tag
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TagInner> createTagAsync(UUID projectId, String name, String description, final ServiceCallback<TagInner> serviceCallback) {
        return ServiceFuture.fromResponse(createTagWithServiceResponseAsync(projectId, name, description), serviceCallback);
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @param description Optional description for the tag
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<TagInner> createTagAsync(UUID projectId, String name, String description) {
        return createTagWithServiceResponseAsync(projectId, name, description).map(new Func1<ServiceResponse<TagInner>, TagInner>() {
            @Override
            public TagInner call(ServiceResponse<TagInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Create a tag for the project.
     *
     * @param projectId The project id
     * @param name The tag name
     * @param description Optional description for the tag
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TagInner object
     */
    public Observable<ServiceResponse<TagInner>> createTagWithServiceResponseAsync(UUID projectId, String name, String description) {
        if (projectId == null) {
            throw new IllegalArgumentException("Parameter projectId is required and cannot be null.");
        }
        if (name == null) {
            throw new IllegalArgumentException("Parameter name is required and cannot be null.");
        }
        if (this.apiKey() == null) {
            throw new IllegalArgumentException("Parameter this.apiKey() is required and cannot be null.");
        }
        return service.createTag(projectId, name, description, this.apiKey(), this.acceptLanguage(), this.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TagInner>>>() {
                @Override
                public Observable<ServiceResponse<TagInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TagInner> clientResponse = createTagDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TagInner> createTagDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TagInner, CloudException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TagInner>() { }.getType())
                .registerError(CloudException.class)
                .build(response);
    }

}
