/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.reservations.implementation;

import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.AzureServiceFuture;
import com.microsoft.azure.ListOperationCallback;
import com.microsoft.azure.management.reservations.ErrorException;
import com.microsoft.azure.management.reservations.MergeRequest;
import com.microsoft.azure.management.reservations.Patch;
import com.microsoft.azure.management.reservations.SplitRequest;
import com.microsoft.azure.Page;
import com.microsoft.azure.PagedList;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.http.Url;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Reservations.
 */
public class ReservationsInner {
    /** The Retrofit service to perform REST calls. */
    private ReservationsService service;
    /** The service client containing this operation class. */
    private AzureReservationAPIImpl client;

    /**
     * Initializes an instance of ReservationsInner.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ReservationsInner(Retrofit retrofit, AzureReservationAPIImpl client) {
        this.service = retrofit.create(ReservationsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Reservations to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ReservationsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations split" })
        @POST("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/split")
        Observable<Response<ResponseBody>> split(@Path("reservationOrderId") String reservationOrderId, @Query("api-version") String apiVersion, @Body SplitRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations beginSplit" })
        @POST("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/split")
        Observable<Response<ResponseBody>> beginSplit(@Path("reservationOrderId") String reservationOrderId, @Query("api-version") String apiVersion, @Body SplitRequest body, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations merge" })
        @POST("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/merge")
        Observable<Response<ResponseBody>> merge(@Path("reservationOrderId") String reservationOrderId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body MergeRequest body, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations beginMerge" })
        @POST("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/merge")
        Observable<Response<ResponseBody>> beginMerge(@Path("reservationOrderId") String reservationOrderId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Body MergeRequest body, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations list" })
        @GET("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations")
        Observable<Response<ResponseBody>> list(@Path("reservationOrderId") String reservationOrderId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations get" })
        @GET("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}")
        Observable<Response<ResponseBody>> get(@Path("reservationId") String reservationId, @Path("reservationOrderId") String reservationOrderId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations update" })
        @PATCH("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}")
        Observable<Response<ResponseBody>> update(@Path("reservationOrderId") String reservationOrderId, @Path("reservationId") String reservationId, @Query("api-version") String apiVersion, @Body Patch parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations beginUpdate" })
        @PATCH("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}")
        Observable<Response<ResponseBody>> beginUpdate(@Path("reservationOrderId") String reservationOrderId, @Path("reservationId") String reservationId, @Query("api-version") String apiVersion, @Body Patch parameters, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations listRevisions" })
        @GET("providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}/revisions")
        Observable<Response<ResponseBody>> listRevisions(@Path("reservationId") String reservationId, @Path("reservationOrderId") String reservationOrderId, @Query("api-version") String apiVersion, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations listNext" })
        @GET
        Observable<Response<ResponseBody>> listNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.management.reservations.Reservations listRevisionsNext" })
        @GET
        Observable<Response<ResponseBody>> listRevisionsNext(@Url String nextUrl, @Header("accept-language") String acceptLanguage, @Header("User-Agent") String userAgent);

    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReservationResponseInner&gt; object if successful.
     */
    public List<ReservationResponseInner> split(String reservationOrderId, SplitRequest body) {
        return splitWithServiceResponseAsync(reservationOrderId, body).toBlocking().last().body();
    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> splitAsync(String reservationOrderId, SplitRequest body, final ServiceCallback<List<ReservationResponseInner>> serviceCallback) {
        return ServiceFuture.fromResponse(splitWithServiceResponseAsync(reservationOrderId, body), serviceCallback);
    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<List<ReservationResponseInner>> splitAsync(String reservationOrderId, SplitRequest body) {
        return splitWithServiceResponseAsync(reservationOrderId, body).map(new Func1<ServiceResponse<List<ReservationResponseInner>>, List<ReservationResponseInner>>() {
            @Override
            public List<ReservationResponseInner> call(ServiceResponse<List<ReservationResponseInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<List<ReservationResponseInner>>> splitWithServiceResponseAsync(String reservationOrderId, SplitRequest body) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        Observable<Response<ResponseBody>> observable = service.split(reservationOrderId, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<List<ReservationResponseInner>>() { }.getType());
    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReservationResponseInner&gt; object if successful.
     */
    public List<ReservationResponseInner> beginSplit(String reservationOrderId, SplitRequest body) {
        return beginSplitWithServiceResponseAsync(reservationOrderId, body).toBlocking().single().body();
    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> beginSplitAsync(String reservationOrderId, SplitRequest body, final ServiceCallback<List<ReservationResponseInner>> serviceCallback) {
        return ServiceFuture.fromResponse(beginSplitWithServiceResponseAsync(reservationOrderId, body), serviceCallback);
    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReservationResponseInner&gt; object
     */
    public Observable<List<ReservationResponseInner>> beginSplitAsync(String reservationOrderId, SplitRequest body) {
        return beginSplitWithServiceResponseAsync(reservationOrderId, body).map(new Func1<ServiceResponse<List<ReservationResponseInner>>, List<ReservationResponseInner>>() {
            @Override
            public List<ReservationResponseInner> call(ServiceResponse<List<ReservationResponseInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Split the `Reservation`.
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReservationResponseInner&gt; object
     */
    public Observable<ServiceResponse<List<ReservationResponseInner>>> beginSplitWithServiceResponseAsync(String reservationOrderId, SplitRequest body) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (body == null) {
            throw new IllegalArgumentException("Parameter body is required and cannot be null.");
        }
        Validator.validate(body);
        return service.beginSplit(reservationOrderId, this.client.apiVersion(), body, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReservationResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ReservationResponseInner>> clientResponse = beginSplitDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ReservationResponseInner>> beginSplitDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ReservationResponseInner>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ReservationResponseInner>>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReservationResponseInner&gt; object if successful.
     */
    public List<ReservationResponseInner> merge(String reservationOrderId) {
        return mergeWithServiceResponseAsync(reservationOrderId).toBlocking().last().body();
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> mergeAsync(String reservationOrderId, final ServiceCallback<List<ReservationResponseInner>> serviceCallback) {
        return ServiceFuture.fromResponse(mergeWithServiceResponseAsync(reservationOrderId), serviceCallback);
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<List<ReservationResponseInner>> mergeAsync(String reservationOrderId) {
        return mergeWithServiceResponseAsync(reservationOrderId).map(new Func1<ServiceResponse<List<ReservationResponseInner>>, List<ReservationResponseInner>>() {
            @Override
            public List<ReservationResponseInner> call(ServiceResponse<List<ReservationResponseInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<List<ReservationResponseInner>>> mergeWithServiceResponseAsync(String reservationOrderId) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final String sourcesConverted = null;
        MergeRequest body = new MergeRequest();
        body.withSources(null);
        Observable<Response<ResponseBody>> observable = service.merge(reservationOrderId, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<List<ReservationResponseInner>>() { }.getType());
    }
    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReservationResponseInner&gt; object if successful.
     */
    public List<ReservationResponseInner> merge(String reservationOrderId, List<String> sources) {
        return mergeWithServiceResponseAsync(reservationOrderId, sources).toBlocking().last().body();
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> mergeAsync(String reservationOrderId, List<String> sources, final ServiceCallback<List<ReservationResponseInner>> serviceCallback) {
        return ServiceFuture.fromResponse(mergeWithServiceResponseAsync(reservationOrderId, sources), serviceCallback);
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<List<ReservationResponseInner>> mergeAsync(String reservationOrderId, List<String> sources) {
        return mergeWithServiceResponseAsync(reservationOrderId, sources).map(new Func1<ServiceResponse<List<ReservationResponseInner>>, List<ReservationResponseInner>>() {
            @Override
            public List<ReservationResponseInner> call(ServiceResponse<List<ReservationResponseInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<List<ReservationResponseInner>>> mergeWithServiceResponseAsync(String reservationOrderId, List<String> sources) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(sources);
        MergeRequest body = new MergeRequest();
        body.withSources(sources);
        Observable<Response<ResponseBody>> observable = service.merge(reservationOrderId, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<List<ReservationResponseInner>>() { }.getType());
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReservationResponseInner&gt; object if successful.
     */
    public List<ReservationResponseInner> beginMerge(String reservationOrderId) {
        return beginMergeWithServiceResponseAsync(reservationOrderId).toBlocking().single().body();
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> beginMergeAsync(String reservationOrderId, final ServiceCallback<List<ReservationResponseInner>> serviceCallback) {
        return ServiceFuture.fromResponse(beginMergeWithServiceResponseAsync(reservationOrderId), serviceCallback);
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReservationResponseInner&gt; object
     */
    public Observable<List<ReservationResponseInner>> beginMergeAsync(String reservationOrderId) {
        return beginMergeWithServiceResponseAsync(reservationOrderId).map(new Func1<ServiceResponse<List<ReservationResponseInner>>, List<ReservationResponseInner>>() {
            @Override
            public List<ReservationResponseInner> call(ServiceResponse<List<ReservationResponseInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReservationResponseInner&gt; object
     */
    public Observable<ServiceResponse<List<ReservationResponseInner>>> beginMergeWithServiceResponseAsync(String reservationOrderId) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final List<String> sources = null;
        MergeRequest body = new MergeRequest();
        body.withSources(null);
        return service.beginMerge(reservationOrderId, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReservationResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ReservationResponseInner>> clientResponse = beginMergeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ReservationResponseInner&gt; object if successful.
     */
    public List<ReservationResponseInner> beginMerge(String reservationOrderId, List<String> sources) {
        return beginMergeWithServiceResponseAsync(reservationOrderId, sources).toBlocking().single().body();
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> beginMergeAsync(String reservationOrderId, List<String> sources, final ServiceCallback<List<ReservationResponseInner>> serviceCallback) {
        return ServiceFuture.fromResponse(beginMergeWithServiceResponseAsync(reservationOrderId, sources), serviceCallback);
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReservationResponseInner&gt; object
     */
    public Observable<List<ReservationResponseInner>> beginMergeAsync(String reservationOrderId, List<String> sources) {
        return beginMergeWithServiceResponseAsync(reservationOrderId, sources).map(new Func1<ServiceResponse<List<ReservationResponseInner>>, List<ReservationResponseInner>>() {
            @Override
            public List<ReservationResponseInner> call(ServiceResponse<List<ReservationResponseInner>> response) {
                return response.body();
            }
        });
    }

    /**
     * Merges two `Reservation`s.
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged must have same properties.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param sources Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ReservationResponseInner&gt; object
     */
    public Observable<ServiceResponse<List<ReservationResponseInner>>> beginMergeWithServiceResponseAsync(String reservationOrderId, List<String> sources) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(sources);
        MergeRequest body = new MergeRequest();
        body.withSources(sources);
        return service.beginMerge(reservationOrderId, this.client.apiVersion(), this.client.acceptLanguage(), body, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<ReservationResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ReservationResponseInner>> clientResponse = beginMergeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ReservationResponseInner>> beginMergeDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<List<ReservationResponseInner>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<ReservationResponseInner>>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ReservationResponseInner&gt; object if successful.
     */
    public PagedList<ReservationResponseInner> list(final String reservationOrderId) {
        ServiceResponse<Page<ReservationResponseInner>> response = listSinglePageAsync(reservationOrderId).toBlocking().single();
        return new PagedList<ReservationResponseInner>(response.body()) {
            @Override
            public Page<ReservationResponseInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> listAsync(final String reservationOrderId, final ListOperationCallback<ReservationResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSinglePageAsync(reservationOrderId),
            new Func1<String, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<Page<ReservationResponseInner>> listAsync(final String reservationOrderId) {
        return listWithServiceResponseAsync(reservationOrderId)
            .map(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Page<ReservationResponseInner>>() {
                @Override
                public Page<ReservationResponseInner> call(ServiceResponse<Page<ReservationResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listWithServiceResponseAsync(final String reservationOrderId) {
        return listSinglePageAsync(reservationOrderId)
            .concatMap(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(ServiceResponse<Page<ReservationResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
    ServiceResponse<PageImpl<ReservationResponseInner>> * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ReservationResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listSinglePageAsync(final String reservationOrderId) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.list(reservationOrderId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ReservationResponseInner>> result = listDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ReservationResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ReservationResponseInner>> listDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ReservationResponseInner>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ReservationResponseInner>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get `Reservation` details.
     * Get specific `Reservation` details.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReservationResponseInner object if successful.
     */
    public ReservationResponseInner get(String reservationId, String reservationOrderId) {
        return getWithServiceResponseAsync(reservationId, reservationOrderId).toBlocking().single().body();
    }

    /**
     * Get `Reservation` details.
     * Get specific `Reservation` details.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReservationResponseInner> getAsync(String reservationId, String reservationOrderId, final ServiceCallback<ReservationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(reservationId, reservationOrderId), serviceCallback);
    }

    /**
     * Get `Reservation` details.
     * Get specific `Reservation` details.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReservationResponseInner object
     */
    public Observable<ReservationResponseInner> getAsync(String reservationId, String reservationOrderId) {
        return getWithServiceResponseAsync(reservationId, reservationOrderId).map(new Func1<ServiceResponse<ReservationResponseInner>, ReservationResponseInner>() {
            @Override
            public ReservationResponseInner call(ServiceResponse<ReservationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Get `Reservation` details.
     * Get specific `Reservation` details.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReservationResponseInner object
     */
    public Observable<ServiceResponse<ReservationResponseInner>> getWithServiceResponseAsync(String reservationId, String reservationOrderId) {
        if (reservationId == null) {
            throw new IllegalArgumentException("Parameter reservationId is required and cannot be null.");
        }
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.get(reservationId, reservationOrderId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReservationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ReservationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReservationResponseInner> clientResponse = getDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ReservationResponseInner> getDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ReservationResponseInner, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ReservationResponseInner>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReservationResponseInner object if successful.
     */
    public ReservationResponseInner update(String reservationOrderId, String reservationId, Patch parameters) {
        return updateWithServiceResponseAsync(reservationOrderId, reservationId, parameters).toBlocking().last().body();
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReservationResponseInner> updateAsync(String reservationOrderId, String reservationId, Patch parameters, final ServiceCallback<ReservationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(reservationOrderId, reservationId, parameters), serviceCallback);
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ReservationResponseInner> updateAsync(String reservationOrderId, String reservationId, Patch parameters) {
        return updateWithServiceResponseAsync(reservationOrderId, reservationId, parameters).map(new Func1<ServiceResponse<ReservationResponseInner>, ReservationResponseInner>() {
            @Override
            public ReservationResponseInner call(ServiceResponse<ReservationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<ServiceResponse<ReservationResponseInner>> updateWithServiceResponseAsync(String reservationOrderId, String reservationId, Patch parameters) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (reservationId == null) {
            throw new IllegalArgumentException("Parameter reservationId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        Observable<Response<ResponseBody>> observable = service.update(reservationOrderId, reservationId, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPutOrPatchResultAsync(observable, new TypeToken<ReservationResponseInner>() { }.getType());
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ReservationResponseInner object if successful.
     */
    public ReservationResponseInner beginUpdate(String reservationOrderId, String reservationId, Patch parameters) {
        return beginUpdateWithServiceResponseAsync(reservationOrderId, reservationId, parameters).toBlocking().single().body();
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ReservationResponseInner> beginUpdateAsync(String reservationOrderId, String reservationId, Patch parameters, final ServiceCallback<ReservationResponseInner> serviceCallback) {
        return ServiceFuture.fromResponse(beginUpdateWithServiceResponseAsync(reservationOrderId, reservationId, parameters), serviceCallback);
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReservationResponseInner object
     */
    public Observable<ReservationResponseInner> beginUpdateAsync(String reservationOrderId, String reservationId, Patch parameters) {
        return beginUpdateWithServiceResponseAsync(reservationOrderId, reservationId, parameters).map(new Func1<ServiceResponse<ReservationResponseInner>, ReservationResponseInner>() {
            @Override
            public ReservationResponseInner call(ServiceResponse<ReservationResponseInner> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a `Reservation`.
     * Updates the applied scopes of the `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the Reservation Item
     * @param parameters Information needed to patch a reservation item
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ReservationResponseInner object
     */
    public Observable<ServiceResponse<ReservationResponseInner>> beginUpdateWithServiceResponseAsync(String reservationOrderId, String reservationId, Patch parameters) {
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (reservationId == null) {
            throw new IllegalArgumentException("Parameter reservationId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        if (parameters == null) {
            throw new IllegalArgumentException("Parameter parameters is required and cannot be null.");
        }
        Validator.validate(parameters);
        return service.beginUpdate(reservationOrderId, reservationId, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ReservationResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<ReservationResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ReservationResponseInner> clientResponse = beginUpdateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ReservationResponseInner> beginUpdateDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ReservationResponseInner, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<ReservationResponseInner>() { }.getType())
                .register(202, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ReservationResponseInner&gt; object if successful.
     */
    public PagedList<ReservationResponseInner> listRevisions(final String reservationId, final String reservationOrderId) {
        ServiceResponse<Page<ReservationResponseInner>> response = listRevisionsSinglePageAsync(reservationId, reservationOrderId).toBlocking().single();
        return new PagedList<ReservationResponseInner>(response.body()) {
            @Override
            public Page<ReservationResponseInner> nextPage(String nextPageLink) {
                return listRevisionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> listRevisionsAsync(final String reservationId, final String reservationOrderId, final ListOperationCallback<ReservationResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listRevisionsSinglePageAsync(reservationId, reservationOrderId),
            new Func1<String, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(String nextPageLink) {
                    return listRevisionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<Page<ReservationResponseInner>> listRevisionsAsync(final String reservationId, final String reservationOrderId) {
        return listRevisionsWithServiceResponseAsync(reservationId, reservationOrderId)
            .map(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Page<ReservationResponseInner>>() {
                @Override
                public Page<ReservationResponseInner> call(ServiceResponse<Page<ReservationResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param reservationId Id of the Reservation Item
     * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listRevisionsWithServiceResponseAsync(final String reservationId, final String reservationOrderId) {
        return listRevisionsSinglePageAsync(reservationId, reservationOrderId)
            .concatMap(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(ServiceResponse<Page<ReservationResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listRevisionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
    ServiceResponse<PageImpl<ReservationResponseInner>> * @param reservationId Id of the Reservation Item
    ServiceResponse<PageImpl<ReservationResponseInner>> * @param reservationOrderId Order Id of the reservation
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ReservationResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listRevisionsSinglePageAsync(final String reservationId, final String reservationOrderId) {
        if (reservationId == null) {
            throw new IllegalArgumentException("Parameter reservationId is required and cannot be null.");
        }
        if (reservationOrderId == null) {
            throw new IllegalArgumentException("Parameter reservationOrderId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.listRevisions(reservationId, reservationOrderId, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ReservationResponseInner>> result = listRevisionsDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ReservationResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ReservationResponseInner>> listRevisionsDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ReservationResponseInner>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ReservationResponseInner>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ReservationResponseInner&gt; object if successful.
     */
    public PagedList<ReservationResponseInner> listNext(final String nextPageLink) {
        ServiceResponse<Page<ReservationResponseInner>> response = listNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ReservationResponseInner>(response.body()) {
            @Override
            public Page<ReservationResponseInner> nextPage(String nextPageLink) {
                return listNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> listNextAsync(final String nextPageLink, final ServiceFuture<List<ReservationResponseInner>> serviceFuture, final ListOperationCallback<ReservationResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(String nextPageLink) {
                    return listNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<Page<ReservationResponseInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Page<ReservationResponseInner>>() {
                @Override
                public Page<ReservationResponseInner> call(ServiceResponse<Page<ReservationResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listNextWithServiceResponseAsync(final String nextPageLink) {
        return listNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(ServiceResponse<Page<ReservationResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get `Reservation`s in a given reservation Order.
     * List `Reservation`s within a single `ReservationOrder`.
     *
    ServiceResponse<PageImpl<ReservationResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ReservationResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ReservationResponseInner>> result = listNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ReservationResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ReservationResponseInner>> listNextDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ReservationResponseInner>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ReservationResponseInner>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedList&lt;ReservationResponseInner&gt; object if successful.
     */
    public PagedList<ReservationResponseInner> listRevisionsNext(final String nextPageLink) {
        ServiceResponse<Page<ReservationResponseInner>> response = listRevisionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<ReservationResponseInner>(response.body()) {
            @Override
            public Page<ReservationResponseInner> nextPage(String nextPageLink) {
                return listRevisionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @param serviceFuture the ServiceFuture object tracking the Retrofit calls
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ReservationResponseInner>> listRevisionsNextAsync(final String nextPageLink, final ServiceFuture<List<ReservationResponseInner>> serviceFuture, final ListOperationCallback<ReservationResponseInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listRevisionsNextSinglePageAsync(nextPageLink),
            new Func1<String, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(String nextPageLink) {
                    return listRevisionsNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<Page<ReservationResponseInner>> listRevisionsNextAsync(final String nextPageLink) {
        return listRevisionsNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Page<ReservationResponseInner>>() {
                @Override
                public Page<ReservationResponseInner> call(ServiceResponse<Page<ReservationResponseInner>> response) {
                    return response.body();
                }
            });
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
     * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedList&lt;ReservationResponseInner&gt; object
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listRevisionsNextWithServiceResponseAsync(final String nextPageLink) {
        return listRevisionsNextSinglePageAsync(nextPageLink)
            .concatMap(new Func1<ServiceResponse<Page<ReservationResponseInner>>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(ServiceResponse<Page<ReservationResponseInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listRevisionsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }

    /**
     * Get `Reservation` revisions.
     * List of all the revisions for the `Reservation`.
     *
    ServiceResponse<PageImpl<ReservationResponseInner>> * @param nextPageLink The NextLink from the previous successful call to List operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the PagedList&lt;ReservationResponseInner&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Observable<ServiceResponse<Page<ReservationResponseInner>>> listRevisionsNextSinglePageAsync(final String nextPageLink) {
        if (nextPageLink == null) {
            throw new IllegalArgumentException("Parameter nextPageLink is required and cannot be null.");
        }
        String nextUrl = String.format("%s", nextPageLink);
        return service.listRevisionsNext(nextUrl, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<ReservationResponseInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ReservationResponseInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<ReservationResponseInner>> result = listRevisionsNextDelegate(response);
                        return Observable.just(new ServiceResponse<Page<ReservationResponseInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PageImpl<ReservationResponseInner>> listRevisionsNextDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<PageImpl<ReservationResponseInner>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<PageImpl<ReservationResponseInner>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
